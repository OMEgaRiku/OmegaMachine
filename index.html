<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>OMEGA STONE</title>
<link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text x=%2250%22 y=%2250%22 font-size=%2290%22 text-anchor=%22middle%22 dominant-baseline=%22central%22 fill=%22%23d4af37%22 style=%22font-family:serif; font-weight:bold;%22>Ω</text></svg>">


<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@700&family=Shippori+Mincho:wght@400;700&display=swap" rel="stylesheet">
<style>
  :root {
    --bg-color: #050505;
    --text-main: #e0d0b0;
    --accent-color: #d4af37;
  }

  body {
    font-family: 'Shippori Mincho', serif;
    background-color: var(--bg-color);
    background-image: radial-gradient(circle at 50% 50%, #1a150e 0%, #000000 100%);
    color: var(--text-main);
    text-align: center;
    padding: 20px;
    margin: 0;
    min-height: 100vh;
    box-sizing: border-box;
    -webkit-tap-highlight-color: transparent;
    transition: background-image 1s ease;
  }
  .en-font { font-family: 'Cinzel', serif; }

  /* Title Screen */
  #title-screen {
    display: flex; flex-direction: column; justify-content: center; align-items: center; height: 90vh; animation: fadeIn 2s;
  }
  .game-title {
    font-family: 'Cinzel', serif; font-size: 2.5rem; font-weight: 900; letter-spacing: 3px;
    background: linear-gradient(to bottom, #fff, #aaa); -webkit-background-clip: text; color: transparent;
    text-shadow: 0 0 20px rgba(255, 255, 255, 0.3); margin-bottom: 5px;
  }

  /* Difficulty Buttons */
  .btn {
    background: rgba(0,0,0,0.5); border: 1px solid #777; color: #ccc; padding: 18px; margin: 8px;
    font-size: 1.1rem; font-family: 'Shippori Mincho', serif; font-weight: bold; cursor: pointer;
    width: 90%; max-width: 350px; position: relative; overflow: hidden; transition: 0.3s; border-radius: 8px;
    display: flex; justify-content: space-between; align-items: center;
  }
  .btn:active { transform: scale(0.98); }
  
  .btn-std { border-color: #3498db; color: #aed6f1; box-shadow: 0 0 10px rgba(52, 152, 219, 0.2); }
  .btn-hard { border-color: #e74c3c; color: #f5b7b1; box-shadow: 0 0 10px rgba(231, 76, 60, 0.2); }
  .btn-night { border-color: #9b59b6; color: #d7bde2; box-shadow: 0 0 10px rgba(155, 89, 182, 0.2); }
    /* Chaos Button - 茶色に変更 */
  .btn-chaos { border-color: #8d6e63; color: #d7ccc8; box-shadow: 0 0 10px rgba(141, 110, 99, 0.2); 
  }
  
  /* 履歴のラベル色 - 茶色 */
  .mode-chaos { background: #4e342e; color: #d7ccc8; }

  
  /* Omega Mode Styles */
  .btn-omega { 
    border-color: #fff; color: #fff; background: #000; 
    box-shadow: 0 0 15px rgba(255, 255, 255, 0.5); font-family: 'Cinzel', serif;
  }

  /* Game Screen */
  #game-screen { display: none; max-width: 600px; margin: 0 auto; animation: slideIn 0.5s ease-out; }
  @keyframes slideIn { from { opacity:0; transform:translateY(20px); } to { opacity:1; transform:translateY(0); } }

  .hud {
    display: flex; justify-content: space-between; align-items: center; border-bottom: 1px solid rgba(255,255,255,0.2);
    padding-bottom: 10px; margin-bottom: 20px; font-family: 'Cinzel', serif;
  }
  .hud-left { display: flex; gap: 8px; }
  .hud-btn { 
    cursor: pointer; font-size: 0.85rem; color: #aaa; border: 1px solid #555; 
    padding: 6px 12px; border-radius: 4px; background: rgba(0,0,0,0.6); 
    display: flex; align-items: center; justify-content: center;
  }
  .btn-guide { border-color: #d4af37; color: #f1c40f; font-weight: bold; }
  .mana-bar { font-size: 1.1rem; color: #fff; text-shadow: 0 0 10px rgba(255,255,255,0.5); }

  /* Rune Inputs */
  .rune-container {
    display: flex; justify-content: center; gap: 12px; margin-bottom: 20px;
    background: rgba(0,0,0,0.4); padding: 20px 10px; border-radius: 15px; border: 1px solid rgba(255,255,255,0.1);
  }
  .rune-wrapper { position: relative; width: 80px; }
  .rune-label { position: absolute; top: -28px; left: 0; width: 100%; font-size: 0.8rem; font-weight: bold; }
  .rune-sub { font-size: 0.6rem; color: #888; display: block; margin-top: -2px; font-family: 'Cinzel', serif; }
  
  input.rune-input {
    width: 100%; height: 75px; font-size: 2.2rem; text-align: center; background: #0f0f0f;
    border: 2px solid #333; border-radius: 8px; color: #fff; font-family: 'Cinzel', serif; transition: 0.3s;
  }
  input:focus { outline: none; border-color: #fff; box-shadow: 0 0 15px rgba(255,255,255,0.3); }
  
  #r1 { border-color: #8a1c1c; color: #ff9999; } /* Ignis */
  #r2 { border-color: #1c4e8a; color: #99ccff; } /* Aqua */
  #r3 { border-color: #1c8a5e; color: #99ffcc; } /* Ventus */

  /* Logic Matrix */
  .logic-grid {
    display: grid; grid-template-columns: auto repeat(5, 1fr); gap: 4px;
    margin: 10px 0 10px 0; background: rgba(0,0,0,0.6); padding: 10px; border-radius: 8px; border: 1px solid rgba(255,255,255,0.1);
  }
  .grid-header { font-family: 'Cinzel', serif; font-weight: bold; color: #888; font-size: 0.8rem; padding-bottom: 5px;}
  .grid-row-label { text-align: right; padding-right: 10px; font-size: 0.8rem; font-weight: bold; display: flex; align-items: center; justify-content: flex-end;}
  
  .grid-cell {
    background: rgba(255,255,255,0.05); border: 1px solid #333; aspect-ratio: 1; border-radius: 4px;
    cursor: pointer; display: flex; justify-content: center; align-items: center;
    font-weight: bold; font-size: 1.2rem; user-select: none; transition: 0.1s;
  }
  
  /* マトリクスの開閉用 */
.logic-grid {
  /* 既存のデザインはそのまま維持 */
  transition: max-height 0.3s ease-out, opacity 0.3s ease-out, padding 0.3s;
  overflow: hidden;
}

/* 閉じている時のスタイル */
.logic-grid.closed {
  display: none; /* シンプルに非表示にする */
  /* アニメーションにこだわるなら max-height: 0; padding: 0; opacity: 0; などでもOK */
}
  
  /* Shared Cell Styles */
  .cell-x, .memo-btn.is-x { background: rgba(200, 50, 50, 0.2); color: #ff5555; border-color: #552222; }
  .cell-x::after, .memo-btn.is-x::after { content: "×"; }
  
  .cell-o, .memo-btn.is-o { background: rgba(50, 200, 50, 0.2); color: #55ff55; border-color: #225522; }
  .cell-o::after, .memo-btn.is-o::after { content: "○"; }

  /* Memo Toggle & Area */
  .memo-toggle-btn {
    width: 100%; padding: 8px; background: rgba(255,255,255,0.1); border: 1px solid #444; border-radius: 6px;
    color: #aaa; font-size: 0.8rem; cursor: pointer; margin-bottom: 5px; font-weight: bold; transition: 0.2s;
  }
  .memo-toggle-btn:hover { background: rgba(255,255,255,0.2); color: #fff; }

  .memo-area {
    background: rgba(0,0,0,0.4); padding: 10px; border-radius: 8px; margin-bottom: 20px;
    border: 1px solid rgba(255,255,255,0.1); display: flex; flex-direction: column; gap: 8px;
    transition: max-height 0.3s ease-out, opacity 0.3s ease-out; overflow: hidden;
  }
  .memo-area.closed { display: none; }

  .memo-row { display: flex; gap: 5px; justify-content: center; flex-wrap: wrap; }
  .memo-label { width: 100%; font-size: 0.7rem; color: #888; margin-bottom: 2px; text-align: left; padding-left: 5px;}
  .memo-btn {
    border: 1px solid #444; background: #111; color: #ccc; padding: 6px 8px; border-radius: 4px;
    font-size: 0.75rem; cursor: pointer; min-width: 45px; display: flex; align-items: center; justify-content: center; gap: 3px; user-select: none;
  }
  .memo-btn::after { margin-left: 2px; font-weight: bold; }

  /* Prophecy List */
  .prophecy-list { display: flex; flex-direction: column; gap: 10px; }
  .stone {
    background: linear-gradient(to right, rgba(30,30,30,0.9), rgba(10,10,10,0.9));
    border: 1px solid #444; padding: 10px 15px;
    border-radius: 5px; cursor: pointer; text-align: left; transition: 0.2s;
    display: flex; justify-content: space-between; align-items: center; position: relative;
    backdrop-filter: blur(5px);
  }
  .stone:hover { border-color: #aaa; transform: translateX(5px); }
  .stone::after { content: ''; position: absolute; top:0; left:0; width: 4px; height: 100%; background: #666; }
  .stone.disabled { opacity: 0.4; pointer-events: none; }
  .stone-title { font-size: 0.75rem; color: #888; margin-bottom: 2px; }
  .stone-text { font-size: 1rem; color: #fff; font-weight: bold; letter-spacing: 0.5px; }
  .stone-id { font-family: 'Cinzel', serif; font-size: 1.4rem; color: #444; margin-left: 10px;}
  /* 予言リスト開閉用 */
.prophecy-list.closed {
  display: none;
}

  
      /* Mystery Stone (Omega) - 基本スタイル（アニメーションなし） */
  .stone.is-mystery {
    color: #d4af37;
    background: radial-gradient(circle, #1a1505 0%, #000 100%);
    border: 1px solid #d4af37;
    display: flex; justify-content: center; align-items: center;
    
    box-shadow: 0 0 10px rgba(212, 175, 55, 0.2);
    transition: all 0.5s ease;
  }

  /* 着地した後に追加するクラス（ここで光らせる） */
  .stone.is-mystery.omega-pulsing {
    animation: omegaPulse 3s infinite alternate;
  }

  /* 判定済み（disabled）のスタイル */
  .stone.is-mystery.disabled {
    animation: none; /* 光を止める */
    border-color: #333;
    color: #333;
    background: #050505;
    box-shadow: none;
    opacity: 0.3;
    filter: grayscale(100%);
    cursor: not-allowed;
  }

  .stone.is-mystery .stone-text { 
    font-family: 'Cinzel', serif; 
    font-size: 1.5rem; 
    letter-spacing: 5px; 
    color: #d4af37;
    text-shadow: 0 0 8px rgba(212, 175, 55, 0.6);
  }
  
  .stone.is-mystery.disabled .stone-text {
    color: #333;
    text-shadow: none;
  }

  /* 黄金の呼吸アニメーション */
  @keyframes omegaPulse {
    0% {
      box-shadow: 0 0 5px rgba(212, 175, 55, 0.2), inset 0 0 10px rgba(0,0,0,0.8);
      border-color: #8a7326;
    }
    100% {
      box-shadow: 0 0 25px rgba(212, 175, 55, 0.5), inset 0 0 20px rgba(212, 175, 55, 0.1);
      border-color: #ffe066;
    }
  }

  /* Log */
  .log-area {
    margin-top: 20px; border-top: 1px solid #444; padding-top: 10px; max-height: 200px; overflow-y: auto; text-align: left; font-size: 0.9rem;
  }
  .log-entry { margin-bottom: 5px; padding: 8px 10px; border-radius: 4px; background: rgba(255,255,255,0.05); display: flex; justify-content: space-between; align-items: center; }
  /* TRUE: 緑→金 (神聖な正解) */
  .log-true { border-left: 3px solid #d4af37; color: #ffd700; background: rgba(212, 175, 55, 0.1); }
  /* FALSE: 赤→紫 (虚無・不正解) */
  .log-false { border-left: 3px solid #9b59b6; color: #d7bde2; background: rgba(155, 89, 182, 0.1); }
  
  /* 数字の強調用クラス */
  .num-fire { color: #ff9999; font-weight: bold; }
  .num-water { color: #99ccff; font-weight: bold; }
  .num-wind { color: #99ffcc; font-weight: bold; }

  /* メモ欄をフリーテキスト化 --- */
  .memo-textarea {
    width: 100%;
    height: 120px;
    background: #000;
    border: 1px solid #444;
    color: #e0d0b0;
    padding: 10px;
    font-family: 'Shippori Mincho', serif;
    font-size: 0.9rem;
    resize: none;
    box-sizing: border-box;
    border-radius: 4px;
    line-height: 1.5;
    transition: 0.3s;
  }
  .memo-textarea:focus {
    outline: none;
    border-color: #d4af37;
    box-shadow: 0 0 10px rgba(212, 175, 55, 0.2);
    background: #111;
  }
  .memo-textarea::placeholder {
    color: #444;
    font-style: italic;
  }
  .log-nums { font-family: 'Cinzel', serif; font-weight: bold; background: #000; padding: 1px 6px; border-radius: 3px; letter-spacing: 1px; font-size: 0.8rem;}

  /* Action Bar */
  .action-bar { margin-top: 20px; display: flex; gap: 10px; justify-content: center; }
  .btn-action { flex: 1; padding: 15px; font-weight: bold; font-family: 'Shippori Mincho', serif; border: none; cursor: pointer; border-radius: 8px; font-size: 1rem; color: #fff; transition: 0.2s; }
  .btn-next { background: #333; border: 1px solid #555; }
  .btn-solve { background: #27ae60; box-shadow: 0 4px 0 #1e8449; }

  /* Chaos Bar */
  .chaos-bar { background: #c0392b; color: white; padding: 5px; font-size: 0.8rem; font-weight: bold; margin-bottom: 15px; border-radius: 4px; display: none; text-shadow: 0 0 5px #000; letter-spacing: 2px;}

  /* Modals */
  .modal-overlay {
    display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%;
    background: rgba(0,0,0,0.9); z-index: 10000; flex-direction: column; justify-content: center; align-items: center;
    backdrop-filter: blur(5px);
  }
  .seal-broken { font-size: 2.5rem; color: #fff; text-shadow: 0 0 30px #fff; font-weight: bold; }
  .answer-reveal { font-size: 4rem; letter-spacing: 15px; margin: 20px; color: #fff; font-family: 'Cinzel', serif; }

  /* Help & History Styles */
  #help-content, #history-content {
    background: #111; border: 1px solid #444; padding: 20px; border-radius: 10px; width: 85%; max-width: 500px;
    max-height: 80vh; overflow-y: auto; text-align: left; position: relative; box-shadow: 0 0 20px rgba(0,0,0,0.8);
  }
  .help-section { margin-bottom: 25px; border-bottom: 1px dashed #333; padding-bottom: 15px; }
  .help-title { color: #d4af37; font-weight: bold; margin-bottom: 10px; font-size: 1.1rem; display: flex; align-items: center; gap: 8px;}
  .help-text { font-size: 0.9rem; line-height: 1.6; color: #ccc; }
  /* 閉じるボタン（スクロールしても追従するように変更） */
.close-help { 
  position: sticky !important; /* absolute から sticky に変更 */
  top: 0; 
  float: right; /* 右に寄せる */
  font-size: 2rem; /* 少し大きくして押しやすく */
  cursor: pointer; 
  color: #888; 
  padding: 5px 10px;
  background: #111; /* 背景をつけて文字と被らないように */
  border-radius: 0 0 0 8px;
  z-index: 10;
  margin-top: -10px; /* 位置微調整 */
  margin-right: -10px;
}

  
  .diagram-box {
    background: #222; border: 1px solid #444; padding: 15px; border-radius: 6px; margin: 10px 0;
    display: flex; flex-direction: column; align-items: center; justify-content: center;
  }
  .d-stone {
    width: 90%; background: #333; border-left: 3px solid #666; padding: 8px; margin: 5px 0; color: #fff; font-size: 0.8rem; display: flex; justify-content: space-between;
  }
  .d-arrow { font-size: 1.5rem; color: #d4af37; margin: 5px 0; }
  .d-result { font-weight: bold; padding: 2px 8px; border-radius: 4px; font-size: 0.8rem; }
  .d-true { background: rgba(46, 204, 113, 0.2); color: #2ecc71; border: 1px solid #2ecc71; }
  .d-false { background: rgba(231, 76, 60, 0.2); color: #e74c3c; border: 1px solid #e74c3c; }
  
  /* Liar Styles */
  .stone.is-liar {
    border: 2px solid #e74c3c;
    background: linear-gradient(to right, rgba(231, 76, 60, 0.2), rgba(0,0,0,0.8));
  }
  .stone.is-liar::after { background: #e74c3c; }
  .stone.is-liar .stone-title::after {
    content: " (嘘つき)"; color: #e74c3c; font-weight: bold; margin-left: 5px;
  }
  .res-row { font-size: 0.8rem; border-bottom: 1px solid #444; padding: 5px 0; color: #ccc; }
  .res-liar-txt { color: #e74c3c; font-weight:bold; }

    /* Omega Rule List */
  #omega-rule-area {
    margin-top: 15px; padding: 10px; border: 1px solid #444; border-radius: 8px;
    background: rgba(0,0,0,0.8); display: none; text-align: left;
    
    position: relative;
    z-index: 15000;
    overflow: visible !important; /* ← これがないとiPhoneで消えます！ */
  }
  .omega-label { color: #fff; font-size: 0.9rem; margin-bottom: 8px; border-bottom: 1px solid #333; padding-bottom: 5px; }
  .omega-list-item {
    padding: 6px; font-size: 0.85rem; color: #ccc; cursor: pointer; border-bottom: 1px dashed #333; transition: 0.2s;
  }
  .omega-list-item:hover { color: #fff; background: rgba(255,255,255,0.1); }
  .omega-list-item.excluded {
    text-decoration: line-through; color: #555; opacity: 0.6;
  }

  /* History List Styles */
  .hist-item {
    background: #1a1a1a; border: 1px solid #333; border-radius: 6px; padding: 10px;
    margin-bottom: 8px; display: flex; justify-content: space-between; align-items: center;
  }
  .hist-left { text-align: left; }
  .hist-mode { font-size: 0.7rem; padding: 2px 6px; border-radius: 3px; margin-right: 5px; font-weight: bold; }
  .mode-standard { background: #1c4e8a; color: #aed6f1; }
  .mode-hard { background: #8a1c1c; color: #f5b7b1; }
  .mode-nightmare { background: #4a1c8a; color: #d7bde2; }
  .mode-chaos { background: #555; color: #ccc; }
  .mode-omega { background: #000; color: #fff; border: 1px solid #fff; }

  .hist-id { font-family: 'Cinzel', serif; color: #d4af37; font-weight: bold; letter-spacing: 1px; }
  .hist-date { font-size: 0.7rem; color: #666; margin-top: 2px; }
  .hist-result { font-weight: bold; font-size: 0.9rem; }
  .res-win { color: #2ecc71; }
  .res-lose { color: #e74c3c; }

  .btn-replay {
    background: transparent; border: 1px solid #555; color: #aaa; cursor: pointer;
    padding: 5px 10px; border-radius: 4px; font-size: 0.8rem; margin-left: 10px; transition: 0.2s;
  }
  .btn-replay:hover { background: #333; color: #fff; border-color: #fff; }
  
  /* Tutorial Styles */
  .t-container { display: flex; flex-direction: column; gap: 15px; }
  .t-step { background: #1a1a1a; border: 1px solid #444; border-radius: 8px; padding: 15px; position: relative; text-align: left; }
  .t-step-num { background: var(--accent-color); color: #000; font-weight: bold; display: inline-block; padding: 2px 8px; border-radius: 4px; font-size: 0.8rem; margin-bottom: 8px; }
  .t-row { display: flex; align-items: center; justify-content: space-around; margin: 10px 0; background: rgba(0,0,0,0.3); padding: 10px; border-radius: 6px; }
  .t-stone-mock { border: 1px solid #666; padding: 5px 10px; border-radius: 4px; font-size: 0.8rem; color: #ccc; background: #222; }
  .t-result-mock { font-weight: bold; font-family: 'Cinzel', serif; padding: 5px 10px; border-radius: 4px; }
  .t-res-true { background: rgba(46, 204, 113, 0.2); color: #2ecc71; border: 1px solid #2ecc71; }
  .t-res-false { background: rgba(231, 76, 60, 0.2); color: #e74c3c; border: 1px solid #e74c3c; }
  .t-logic-text { font-size: 0.9rem; line-height: 1.6; color: #ddd; margin-top: 5px; }
  .t-highlight { color: #ff9999; font-weight: bold; }
  .t-highlight-b { color: #99ccff; font-weight: bold; }
  .t-conclusion { border-top: 1px dashed #444; margin-top: 10px; padding-top: 10px; font-weight: bold; color: var(--accent-color); }

  #loading-indicator { font-size: 1.2rem; color: #d4af37; margin-top: 20px; display: none; }
  @keyframes fadeIn { from { opacity:0; } to { opacity:1; } }
  
    /* --- チュートリアル用スタイル--- */
.title-top-right {
  position: fixed;
  top: max(20px, env(safe-area-inset-top)); 
  right: 20px; 
  left: auto;   /* ←コレ重要！左側は固定しない */
  width: auto;  /* ←コレ重要！勝手に伸びないようにする */
  
  display: flex; 
  gap: 10px; 
  z-index: 20000; 
  pointer-events: auto; 
}

  .btn-tutorial {
    background: rgba(46, 204, 113, 0.2); border: 1px solid #2ecc71; color: #2ecc71;
    padding: 10px 15px; border-radius: 30px; font-weight: bold; cursor: pointer;
    font-size: 0.9rem; display: flex; align-items: center; gap: 5px;
    box-shadow: 0 0 10px rgba(46, 204, 113, 0.2); transition: 0.2s;
  }
  .btn-tutorial:hover { background: rgba(46, 204, 113, 0.4); transform: scale(1.05); }

  /* チュートリアルのメッセージBOX */
  #tut-overlay {
    position: fixed; top: 0; left: 0; width: 100%; height: 100%;
    /* 背景の暗さを少し和らげました (0.7 -> 0.4) */
    background: rgba(0,0,0,0.4); z-index: 2000; display: none;
    pointer-events: auto;
  }
  
  /* ハイライト（穴を開ける） */
  .tut-highlight {
    position: relative; z-index: 2001; 
    /* 周りの暗さも少し和らげました */
    box-shadow: 0 0 0 9999px rgba(0,0,0,0.6); 
    pointer-events: auto; 
    border-radius: 4px;
    transition: all 0.3s ease;
  }

  /* 赤く点滅するアニメーション（注目！） */
  @keyframes blink-red {
    0% { border-color: #ff0000; box-shadow: 0 0 10px rgba(255, 0, 0, 0.5); transform: scale(1); }
    50% { border-color: #ffcccc; box-shadow: 0 0 25px rgba(255, 50, 50, 0.9); transform: scale(1.02); }
    100% { border-color: #ff0000; box-shadow: 0 0 10px rgba(255, 0, 0, 0.5); transform: scale(1); }
  }
  .tut-blink {
    animation: blink-red 1.2s infinite ease-in-out !important;
    border: 2px solid #ff0000 !important;
    background: rgba(0, 0, 0, 0.8) !important; /* 文字が読みやすいように背景を濃く */
  }
  /* --- チュートリアルBOX (強制位置修正版) --- */

  .tut-msg-box {
    position: fixed !important;
    left: 50% !important;
    transform: translateX(-50%) !important;
    width: 92% !important; /* 横幅 */
    max-width: 500px !important;
    background: rgba(15, 15, 20, 0.95) !important;
    border: 1px solid #d4af37 !important;
    border-radius: 8px !important;
    padding: 12px 15px !important; /* パディングを減らす */
    z-index: 9999 !important; /* 最前面に */
    text-align: left !important;
    box-shadow: 0 0 20px rgba(0, 0, 0, 0.9) !important;
    transition: all 0.3s ease !important;
    
    /* デフォルトは「画面の一番下」に配置 */
    bottom: 20px !important;
    top: auto !important;
  }

  /* 上に表示する場合のクラス */
  .tut-pos-top {
    top: 80px !important; /* ヘッダーの下 */
    bottom: auto !important;
  }

  /* 下に表示する場合のクラス (デフォルトと同じだが念のため) */
  .tut-pos-bottom {
    bottom: 20px !important;
    top: auto !important;
  }

  /* テキストサイズ調整 */
  .tut-text {
    color: #fff;
    line-height: 1.4;
    font-size: 0.9rem; /* 文字を少し小さく */
    margin-bottom: 8px;
  }

  /* ボタン調整 */
  .tut-next-btn {
    background: #d4af37;
    color: #000;
    border: none;
    padding: 5px 15px;
    font-weight: bold;
    border-radius: 4px;
    cursor: pointer;
    float: right;
    font-size: 0.8rem;
  }

    
  .tut-msg-box {
    position: fixed; bottom: 120px; left: 50%; transform: translateX(-50%);
    width: 90%; max-width: 500px; background: #111; border: 2px solid #d4af37;
    border-radius: 10px; padding: 20px; z-index: 2002; text-align: left;
    box-shadow: 0 0 20px rgba(212, 175, 55, 0.3);
  }
  .tut-text { color: #fff; line-height: 1.6; font-size: 1rem; margin-bottom: 15px; }
  .tut-next-btn {
    background: #d4af37; color: #000; border: none; padding: 8px 20px;
    font-weight: bold; border-radius: 4px; cursor: pointer; float: right;
  }
  .tut-arrow {
    position: absolute; color: #d4af37; font-size: 2rem; font-weight: bold;
    animation: bounce 1s infinite; z-index: 2003; text-shadow: 0 0 5px #000;
  }
  @keyframes bounce { 0%, 100% { transform:translateY(0); } 50% { transform:translateY(-10px); } }

/* --- チュートリアル用レイアウト --- */
/* 埋め込みモードのメッセージボックス */
.tut-embedded-mode {
  position: relative !important; /* 固定配置を解除 */
  left: auto !important;
  transform: none !important;
  bottom: auto !important;
  top: auto !important;
  
  width: 100% !important;
  max-width: 100% !important;
  margin: 0 0 20px 0 !important;
  box-sizing: border-box !important; 
  background: rgba(20, 20, 25, 0.95) !important;
  border: 1px solid #d4af37 !important;
  border-radius: 8px !important;
  padding: 15px !important;
  box-shadow: 0 0 10px rgba(212, 175, 55, 0.3) !important;
  
  display: flex !important;
  flex-direction: column;
  justify-content: center;
  min-height: 120px; 
}

/* 矢印は埋め込みモードでは消す */
.tut-embedded-mode .tut-arrow {
  display: none !important;
}

/* 結果表示のデザイン */
.tut-result-display {
  font-family: 'Cinzel', serif;
  font-size: 1.4rem;
  font-weight: bold;
  text-align: center;
  margin: 10px 0;
  padding: 8px;
  background: rgba(0,0,0,0.5);
  border-radius: 4px;
}

/* --- Ωモード用メモ欄 (改修版) --- */
.omega-memo-box {
  margin-top: 5px;
  padding: 0 5px;
  /* Flexboxにして入力欄とボタンを横並びに */
  display: flex; 
  gap: 5px;
  align-items: center;
}

.omega-memo-input {
  /* width: 100% を削除し、flex: 1 で残りの幅を埋める */
  flex: 1; 
  box-sizing: border-box;
  background: #000;
  border: 1px solid #444;
  color: #d4af37;
  font-size: 0.8rem;
  padding: 5px;
  border-radius: 4px;
  font-family: 'Shippori Mincho', serif;
  transition: 0.3s;
}
.omega-memo-input:focus {
  outline: none;
  border-color: #d4af37;
  box-shadow: 0 0 5px rgba(212, 175, 55, 0.5);
  background: #111;
}

/* --- 修正箇所: ボタンの枠 --- */
.btn-omega-copy {
  width: 30px;
  height: 30px;
  background: #222;
  border: 1px solid #555;
  border-radius: 4px;
  color: #aaa;
  cursor: pointer;
  display: flex;
  justify-content: center;
  align-items: center;
  font-size: 1rem;
  transition: 0.2s;
  
  /* ▼▼▼ これを追加してください！ ▼▼▼ */
  flex-shrink: 0;  /* 「絶対に縮まない」という命令です */
}

/* --- 新規追加: コピーアイコン画像用 --- */
.copy-icon-img {
  width: 60px;       /* 枠(30px)より少し小さく */
  height: 60px;
  object-fit: contain; /* これで縦横比が崩れなくなります */
  pointer-events: none; /* 画像をクリックしてもボタン反応を邪魔しない */
}

.btn-omega-copy:active {
  transform: scale(0.9);
  background: #444;
}
/* コピー成功時の演出用クラス */
.copy-success {
  border-color: #2ecc71 !important;
  color: #2ecc71 !important;
  background: rgba(46, 204, 113, 0.1) !important;
}

/* --- ロック状態のスタイル --- */
input.rune-input:disabled {
  background: #222;       /* 背景を暗く */
  color: #555;            /* 文字を暗く */
  border-color: #444;     /* 枠線も目立たなく */
  opacity: 0.7;
  cursor: not-allowed;
}

/* ロックメッセージのアニメーション */
@keyframes fadeIn { from { opacity:0; transform:translateY(-5px); } to { opacity:1; transform:translateY(0); } }

/* --- iPhone (iOS Safari) 表示崩れ対策 --- */

/* 1. 入力欄のスタイルを強制リセット＆サイズ固定 */
.rune-input {
  /* iPhone特有の丸みや影を消す */
  -webkit-appearance: none !important; 
  appearance: none !important;
  
  /* 横幅を強制的に広げる */
  width: 80px !important; 
  min-width: 80px !important; /* 念のため最小幅も指定 */
  
  /* 余計な隙間を消す */
  margin: 0;
  border-radius: 8px; /* デザインに合わせて調整してOK */
  box-sizing: border-box; /* 枠線を含めたサイズ計算にする */
}

/* 2. 入力欄を包んでいる箱が潰れないようにする */
.rune-wrapper {
  flex-shrink: 0 !important; /* 「縮むな！」という命令 */
  width: auto !important;
}

/* --- ゲート解放演出 (強化版) --- */

/* モダル全体のアニメーション制御用クラス */
.gate-anim-running {
  /* 子要素のアニメーション発火用 */
}

/* === 十字線演出 (中心拡散・極細版) === */
.lightning-svg {
  position: absolute;
  top: 0; left: 0;
  pointer-events: none;
  opacity: 0;
  transform-origin: center center; /* 中心を軸にする */
}

.lightning-path {
  fill: none;
  stroke: #fffbe0; 
  stroke-width: 0.4px; /* さらに細くして鋭さを出す */
  stroke-linecap: round;
  filter: drop-shadow(0 0 1px #fff) drop-shadow(0 0 3px #d4af37) drop-shadow(0 0 6px #aa771c);
  vector-effect: non-scaling-stroke;
}

.lightning-path.main { stroke-width: 0.6px; }
.lightning-path.sub { stroke-width: 0.2px; opacity: 0.5; }

.lightning-svg.omega-mode .lightning-path {
  stroke: #ffffff !important;
  filter: drop-shadow(0 0 2px #fff) drop-shadow(0 0 8px #fff) !important;
}

.gate-anim-running .lightning-svg {
  animation: explode-discharge 2.5s cubic-bezier(0.1, 0.8, 0.3, 1) forwards;
}

/* 中心から爆発的に広がり、震えるアニメーション */
@keyframes explode-discharge {
  0% { 
    opacity: 0; 
    transform: scale(0.2); /* 中心に凝縮 */
  }
  5% { 
    opacity: 1; 
    transform: scale(1.2); /* 一気に広がる */
  }
  
  /* バチバチと震えるノイズ */
  10%, 30%, 50%, 70%, 90% { transform: scale(1.05) translate(2px, -1px); opacity: 1; }
  20%, 40%, 60%, 80% { transform: scale(1) translate(-2px, 1px); opacity: 0.2; }

  95% { opacity: 1; transform: scale(1.2) filter(brightness(2)); }
  100% { opacity: 0; transform: scale(2); filter: brightness(10); }
}

/* 石板本体 (質感を強化) */
.gate-stone {
  width: 180px; height: 180px; /* 少し大きく */
  /* 点線をやめて、ゴツゴツした実線と多重影に変更 */
  border: 8px solid #2a2a2a;
  border-radius: 50%;
  display: flex; justify-content: center; align-items: center;
  font-family: 'Cinzel', serif; font-size: 6rem; color: #111;
  position: relative;
  /* 岩っぽいテクスチャと内側からの光 */
  background: radial-gradient(circle, #333 0%, #000 100%);
  box-shadow: 
    inset 0 0 30px #000, /* 内側の深い影 */
    0 0 20px rgba(212, 175, 55, 0.3); /* 外側の微かな光 */
  text-shadow: 0 0 5px rgba(212, 175, 55, 0.5); /* 文字の光 */
}

/* 内側の装飾リング */
.gate-inner {
  width: 140px; height: 140px;
  border: 4px solid rgba(212, 175, 55, 0.6); /* 金色のリング */
  border-radius: 50%;
  display: flex; justify-content: center; align-items: center;
}

/* 石板のアニメーション (クラス付与で開始) */
.gate-active {
  animation: gateOpenHeavy 2.5s cubic-bezier(0.7, 0, 0.3, 1) forwards;
}

@keyframes gateOpenHeavy {
  0% { 
    transform: rotate(0deg) scale(1);
    border-color: #2a2a2a; color: #111;
  }
  20% {
    /* 起動: ガガガッと少し回って止まる */
    transform: rotate(45deg) scale(1.1);
    color: #d4af37; border-color: #d4af37;
    box-shadow: inset 0 0 50px #d4af37, 0 0 50px #d4af37;
  }
  40% {
    /*溜め: 一瞬逆回転してエネルギーを溜める */
    transform: rotate(30deg) scale(1.05);
    filter: brightness(1.5);
  }
  100% {
    /* 解放: 一気に加速してホワイトアウト */
    transform: rotate(1080deg) scale(15);
    opacity: 0; filter: brightness(20);
    color: #fff; border-color: #fff;
  }
}

/* --- 予言リスト画面用スタイル --- */
#prophecy-list-content {
  background: #111; border: 1px solid #444; padding: 20px; border-radius: 10px; width: 85%; max-width: 500px;
  max-height: 80vh; overflow-y: auto; text-align: left; position: relative; box-shadow: 0 0 20px rgba(0,0,0,0.8);
}
.p-cat-title {
  margin-top: 20px; margin-bottom: 10px; font-weight: bold; border-left: 4px solid #555; padding-left: 8px; font-size: 0.95rem;
}
.p-item {
  margin-bottom: 12px; font-size: 0.9rem; line-height: 1.5; border-bottom: 1px dashed #333; padding-bottom: 8px; color: #ddd;
}
.p-ex {
  color: #888; font-size: 0.8rem; display: block; margin-top: 2px;
}

/* --- Ωモード特殊演出 (修正版: 天空からの降臨) --- */

/* 1. 開始時: 予言が画面最上部から降ってくる */
@keyframes dropStone {
  0% { 
    transform: translateY(-120vh); /* 画面の遥か上からスタート */
    opacity: 0;
  }
  10% {
    opacity: 1; /* 降り始めですぐ見えるように */
  }
  100% { 
    transform: translateY(0); /* 自分の場所に着地 */
    opacity: 1; 
  }
}

.stone-fall {
  /* 3秒かけてゆっくり、ふんわりと着地する */
  animation: dropStone 3s cubic-bezier(0.2, 0.8, 0.2, 1) forwards;
  opacity: 0; /* 最初は隠しておく */
  
  /* 降ってくる間、他のパーツより手前に表示する */
  position: relative;
  z-index: 100; 
}

/* 2. 解除時: 白色の石板スタイル (変更なし) */
.gate-stone-omega {
  border-color: #fff !important;
  color: #fff !important;
  background: radial-gradient(circle, #555 0%, #000 100%) !important;
  box-shadow: inset 0 0 50px #fff, 0 0 30px #fff !important;
  text-shadow: 0 0 20px #fff !important;
}
.gate-inner-omega {
  border-color: #fff !important;
}

/* 通常の1.5倍の時間 (2.5s * 1.5 = 3.75s) */
.gate-active-omega {
  animation: gateOpenHeavy 3.75s cubic-bezier(0.7, 0, 0.3, 1) forwards !important;
}

/* 3. クリア時: 神々しいフレーム (変更なし) */
.divine-frame {
  position: fixed; top: 0; left: 0; width: 100%; height: 100%;
  pointer-events: none; z-index: 20000;
  box-shadow: inset 0 0 50px #fff, inset 0 0 100px rgba(212, 175, 55, 0.5);
  border: 4px solid #fff;
  animation: divinePulse 3s infinite alternate;
}
@keyframes divinePulse {
  0% { box-shadow: inset 0 0 30px #fff, inset 0 0 80px rgba(212, 175, 55, 0.3); opacity: 0.8; }
  100% { box-shadow: inset 0 0 60px #fff, inset 0 0 150px rgba(212, 175, 55, 0.8); opacity: 1; }
}

/* 斬撃エフェクト本体 */
.slash-effect {
  position: fixed; top: 0; left: 0; width: 100%; height: 100%;
  pointer-events: none; z-index: 30000; display: none;
}
.slash-line {
  position: absolute; background: #fff;
  box-shadow: 0 0 20px #fff, 0 0 40px #ff0000;
  transform: rotate(-20deg);
}

/* 数字が壊される時の震え */
@keyframes glitch-shake {
  0% { transform: translate(0); }
  20% { transform: translate(-5px, 5px); color: #ff0000; }
  40% { transform: translate(-5px, -5px); }
  60% { transform: translate(5px, 5px); }
  80% { transform: translate(5px, -5px); }
  100% { transform: translate(0); }
}
.glitch-active { animation: glitch-shake 0.3s linear infinite; }

/* --- カオスモード演出用 --- */
/* 1. 降り注ぐ禍々しいオーブ */
.chaos-orb {
  position: fixed;
  width: 20px; height: 20px;
  background: radial-gradient(circle, #fff 0%, #9b59b6 30%, #000 100%);
  border-radius: 50%;
  box-shadow: 0 0 10px #9b59b6, 0 0 20px #8e44ad;
  z-index: 9999;
  pointer-events: none;
  opacity: 0;
}
/* 落下アニメーション */
@keyframes chaos-fall {
  0% { transform: translateY(-100px) scale(2); opacity: 0; }
  20% { opacity: 1; }
  100% { transform: translateY(0) scale(1); opacity: 1; }
}

/* 2. 石碑が呪われた時の振動と変色 */
@keyframes chaos-impact {
  0% { transform: scale(1); border-color: #777; }
  10% { transform: scale(1.1); border-color: #9b59b6; background: #2c0e3a; }
  20% { transform: translate(-3px, 3px); }
  40% { transform: translate(3px, -3px); }
  60% { transform: translate(-3px, -3px); }
  80% { transform: translate(3px, 3px); }
  100% { transform: scale(1); border-color: #9b59b6; background: rgba(0,0,0,0.6); }
}
.stone.chaos-infected {
  animation: chaos-impact 0.5s cubic-bezier(.36,.07,.19,.97) forwards;
  /* 憑依後は枠線を紫色に固定 */
  border-color: #9b59b6 !important;
  box-shadow: 0 0 15px rgba(155, 89, 182, 0.3);
}

/* 警告文のじわっと表示 */
.chaos-bar {
  opacity: 0;
  transition: opacity 2s ease-in; 
  
  /* 以下は変更なし */
  background: #c0392b; color: white; padding: 5px; font-size: 0.8rem; 
  font-weight: bold; margin-bottom: 15px; border-radius: 4px; 
  display: none; text-shadow: 0 0 5px #000; letter-spacing: 2px;
}
.chaos-bar.visible {
  opacity: 1;
}

/* タップ時の遅延を無効化して即時反応させる */
button, .btn, .hud-btn, .stone, .memo-btn {
  touch-action: manipulation;
}

       /* アニメーション定義（テスト用に高さを半分に） */
  @keyframes dropInBounce {
    0% {
      opacity: 1; /* ★テスト用: 最初から不透明に */
      transform: translateY(-150vh) scale(0.9); /* ★テスト用: 半分の高さから */
    }
    70% { opacity: 1; transform: translateY(20px) scale(1.05); }
    100% { opacity: 1; transform: translateY(0) scale(1); }
  }

  /* リスト項目のスタイル */
  .omega-list-item {
    opacity: 0; 
    position: relative;
    z-index: 15000; 
  }

/* 降ってくる時のスタイル */
.omega-list-item.falling {
  /* 薄い黄金色の背景（透明度25%） */
  background: rgba(212, 175, 55, 0.25);
  /* はっきりした金の枠線 */
  border: 1px solid #ffd700;
  /* ぼんやり黄金色に光らせる */
  box-shadow: 0 0 15px rgba(255, 215, 0, 0.4);
  
  /* アニメーション設定（そのまま） */
  animation: dropInBounce 3.0s cubic-bezier(0.175, 0.885, 0.32, 1.275) forwards;
}

  /* Awakened Omega Style */
  .btn-awakened {
    border-color: #ff0000;
    color: #ff0000;
    background: #000;
    font-family: 'Cinzel', serif;
    box-shadow: 0 0 10px #500;
    border-style: double;
    border-width: 3px;
    letter-spacing: 1px;
    animation: awakenedPulse 2s infinite alternate;
  }
  .btn-awakened:hover {
    background: #200;
    box-shadow: 0 0 20px #f00;
  }

  @keyframes awakenedPulse {
    0% { text-shadow: 0 0 5px #500; border-color: #800; }
    100% { text-shadow: 0 0 15px #f00; border-color: #f00; }
  }


/* --- 覚醒解放アニメーション --- */
#awakened-unlock-overlay {
  position: fixed;
  top: 0; left: 0; width: 100%; height: 100%;
  background: rgba(0, 0, 0, 0.95);
  z-index: 10000; /* 最前面 */
  display: flex;
  justify-content: center;
  align-items: center;
  flex-direction: column;
  animation: overlayFadeIn 1s forwards;
}

.unlock-content {
  text-align: center;
  color: #ff0000;
  font-family: 'Cinzel', serif;
}

.unlock-icon {
  font-size: 5rem;
  font-weight: bold;
  margin-bottom: 20px;
  text-shadow: 0 0 20px #f00;
  opacity: 0;
  transform: scale(3);
  animation: iconDrop 0.8s cubic-bezier(0.175, 0.885, 0.32, 1.275) forwards 0.5s;
}

.unlock-text-main {
  font-size: 1.5rem;
  color: #fff;
  margin-bottom: 10px;
  opacity: 0;
  letter-spacing: 5px;
  animation: textSlideUp 1s ease-out forwards 1.5s;
}

.unlock-text-sub {
  font-size: 1.2rem;
  color: #ff0000;
  text-shadow: 0 0 10px #800;
  opacity: 0;
  animation: textBlink 2s infinite alternate 2.5s, fadeIn 1s forwards 2.5s;
}

/* Keyframes */
@keyframes overlayFadeIn { from { opacity: 0; } to { opacity: 1; } }
@keyframes iconDrop { 
  to { opacity: 1; transform: scale(1); text-shadow: 0 0 30px #ff0000; } 
}
@keyframes textSlideUp { 
  from { opacity: 0; transform: translateY(20px); } 
  to { opacity: 1; transform: translateY(0); } 
}
@keyframes textBlink {
  0% { text-shadow: 0 0 10px #500; }
  100% { text-shadow: 0 0 20px #f00, 0 0 40px #f00; }
}

  /* ボタン横並び用のコンテナ */
  .mode-row {
    display: flex;
    width: 90%;
    max-width: 350px;
    gap: 8px; /* ボタン間の隙間 */
    margin: 8px 0;
  }
  
  /* モードボタンのスタイル上書き (flexアイテム化) */
  .mode-row .btn {
    margin: 0; /* ラッパー側で制御するのでマージン削除 */
    flex: 1;   /* 横幅いっぱいに広げる */
  }

  /* ブーストボタン (ドクロ) */
  .btn-boost {
    width: 50px; /* 正方形に近い形 */
    background: #111;
    border: 1px solid #444;
    border-radius: 8px;
    color: #444;
    font-size: 1.2rem;
    cursor: pointer;
    display: flex;
    justify-content: center;
    align-items: center;
    transition: 0.3s;
    user-select: none;
  }
  
  /* ONになった時のスタイル (赤く光る) */
  .btn-boost.active {
    border-color: #ff0000;
    color: #ff0000;
    box-shadow: 0 0 10px rgba(255, 0, 0, 0.4);
    background: rgba(50, 0, 0, 0.5);
    animation: boostPulse 1.5s infinite alternate;
  }
  
  @keyframes boostPulse {
    from { text-shadow: 0 0 5px #f00; }
    to { text-shadow: 0 0 15px #f00; transform: scale(1.05); }
  }
  
      /* --- Easy & Standard 完全整列スタイル --- */
  
  /* デフォルト（未解放）：縦積み＆全幅 */
  #easy-std-wrapper {
    display: flex;
    flex-direction: column; /* 縦に積む */
    width: 90%;             /* 下のボタンたちと同じ幅 (90%) */
    max-width: 350px;       /* 下のボタンたちと同じ最大幅 */
    gap: 8px;               /* ボタン同士の間隔 */
    margin: 8px 0;          /* 上下の間隔 */
  }

  /* 縦積みの時、中のボタンを親要素(wrapper)いっぱいに広げる */
  #easy-std-wrapper .btn {
    width: 100% !important;     /* 親の幅に合わせる */
    max-width: none !important; /* ボタン自体の制限を解除 */
    margin: 0 !important;       /* 余計なマージンを消す */
    flex: none;                 /* 縦積み時は伸縮させない */
  }

  /* 解放時：横並び（JSでこのクラスが付く） */
  #easy-std-wrapper.unlocked-row {
    flex-direction: row;        /* 横並びにする */
  }
  
  /* 横並びの時だけ、幅を半分こにする */
  #easy-std-wrapper.unlocked-row .btn {
    flex: 1; 
  }

  /* ブースト時の警告メッセージ */
  .boost-popup {
    position: absolute;
    top: 50%; left: 50%;
    transform: translate(-50%, -50%);
    width: 100%;
    text-align: center;
    
    color: #ff0000;
    font-family: 'Shippori Mincho', serif;
    font-weight: bold;
    font-size: 1.1rem;
    text-shadow: 0 0 5px #000, 0 0 10px #500;
    background: rgba(0,0,0,0.7); /* 文字が見やすいように背景を敷く */
    padding: 5px 0;
    
    pointer-events: none; /* クリックを邪魔しない */
    opacity: 0;
    z-index: 100;
    
    animation: boostMsgFade 2.5s cubic-bezier(0.22, 1, 0.36, 1) forwards;
  }

  @keyframes boostMsgFade {
    0% { opacity: 0; transform: translate(-50%, -40%) scale(0.9); }
    15% { opacity: 1; transform: translate(-50%, -50%) scale(1.05); }
    80% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
    100% { opacity: 0; transform: translate(-50%, -60%); }
  }

  /* --- Easy & Standard ラッパーのスタイル (完全版) --- */
  
  /* デフォルト状態（未解放）：縦積み */
  #easy-std-wrapper {
    display: flex;
    flex-direction: column; /* 縦に積む */
    align-items: center;    /* 真ん中に揃える */
    width: 100%;            /* 横幅は画面いっぱい使う */
    /* ボタン自体にマージンがあるので、ここではgap不要 */
  }

  /* 解放された状態：横並び（JSでこのクラスが付く） */
  #easy-std-wrapper.unlocked-row {
    flex-direction: row;       /* 横に並べる */
    width: 90%;                /* ラッパー自体の幅をボタンに合わせる */
    max-width: 350px;
    gap: 8px;                  /* ボタン間の隙間 */
    margin: 8px 0;             /* 上下の隙間 */
  }

  /* 横並びになった時の、中身のボタンの調整 */
  #easy-std-wrapper.unlocked-row .btn {
    margin: 0;        /* 横並び時は個別のマージンを消す */
    flex: 1;          /* 仲良く幅を半分こにする */
    width: auto;      /* 幅指定を解除してflexに任せる */
  }

/* レビューモーダル内のログ表示調整 */
#review-log .log-entry {
  /* ログのデザインを維持しつつ、サイズ感を調整 */
  margin-bottom: 4px;
  padding: 6px 8px;
  font-size: 0.75rem; 
}

/* ログ内の数字バッジなども少し小さく */
#review-log .log-nums {
  font-size: 0.7rem;
  padding: 1px 4px;
}

/* --- 判定演出アニメーション --- */

/* 1. ドーンと出る */
.anim-pop-in {
  animation: popIn 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275) forwards;
}

@keyframes popIn {
  0% { transform: scale(0); opacity: 0; }
  60% { transform: scale(1.2); opacity: 1; }
  100% { transform: scale(1); opacity: 1; }
}

/* 2. 下に吸い込まれる */
.anim-drop-down {
  animation: dropToLog 0.5s ease-in forwards;
}

@keyframes dropToLog {
  0% { transform: scale(1) translateY(0); opacity: 1; }
  100% { 
    transform: scale(0.3) translateY(300px); /* 下へ移動して小さくなる */
    opacity: 0; 
  }
}

/* メモアイコン用のスタイル */
.memo-icon-img {
  width: 1.1rem;      /* 文字サイズに合わせる */
  height: 1.1rem;
  vertical-align: middle; /* 文字と高さを合わせる */
  margin-right: 5px;  /* 文字との隙間 */
  margin-bottom: 2px; /* 微調整 */
  filter: drop-shadow(0 0 2px rgba(255,255,255,0.5)); /* 軽く光らせる */
}




/* ドクロ画像のサイズ強制矯正 */
.boost-img {
  width: 64px !important;  /* 強制的に小さくする */
  height: 64px !important;
  object-fit: contain;     /* 形を崩さない */
  
  /* 以下は演出用（お好みで） */
  filter: grayscale(100%) brightness(0.6);
  transition: 0.3s;
}

/* ONになった時の演出 */
.btn-boost.active .boost-img {
  filter: grayscale(0%) drop-shadow(0 0 5px #ff0000) brightness(1.2);
  transform: scale(1.2);
}

/* --- プレイ画面のドクロ用（常時覚醒モード） --- */

/* このクラスがつくと、強制的に赤くなって鼓動する */
.img-danger {
  /* 1. デフォルトの「グレー」を無効化して赤くする */
  filter: grayscale(0%) brightness(1.2) drop-shadow(0 0 5px #ff0000) !important;
  opacity: 1 !important;
  
  /* 2. アニメーションをセット */
  animation: skullPulse 1.2s infinite alternate;
}

/* 鼓動のアニメーション定義 */
@keyframes skullPulse {
  0% {
    transform: scale(1);
    filter: grayscale(0%) brightness(1.2) drop-shadow(0 0 5px #ff0000);
  }
  100% {
    transform: scale(1.15); /* 少し大きくなる */
    /* 光を強くする */
    filter: grayscale(0%) brightness(1.5) drop-shadow(0 0 15px #ff0000);
  }
}

/* --- 下部アイコンメニューのスタイル (透明版) --- */

.icon-menu-row {
  display: flex;
  justify-content: center;
  gap: 15px;               /* 3つ並ぶので狭くする */
  margin-top: 25px;
  width: 100%;
  max-width: 400px;        /* 広がりすぎ防止 */
  margin-left: auto;       /* 中央寄せ */
  margin-right: auto;
}


.icon-menu-item {
  display: flex;
  flex-direction: column;
  align-items: center;
  cursor: pointer;
  width: 80px;
  transition: transform 0.2s;
}

.icon-menu-item:active {
  transform: scale(0.95);
}

/* 以前は「丸い枠」だった部分 → 透明なコンテナに変更 */
.icon-circle {
  width: 50px;
  height: 50px;
  
  /* ▼▼▼ 透明化！ ▼▼▼ */
  background: transparent; 
  border: none;
  box-shadow: none;
  /* ▲▲▲▲▲▲▲▲▲▲▲▲▲▲ */
  
  display: flex;
  justify-content: center;
  align-items: center;
  margin-bottom: 2px; /* 文字との距離を少し詰める */
  transition: 0.3s;
}

/* アイコン画像本体 (枠がないので少し大きく、リッチに) */
.menu-icon-img {
  width: 88px;  /
  height: 88px;
  object-fit: contain;
  
  /* 常時、少しだけ魔法の光を帯びさせる */
  filter: drop-shadow(0 0 3px rgba(255, 255, 255, 0.3));
  opacity: 0.8; /* 少し透けさせて馴染ませる */
  transition: 0.3s;
}

/* 下の文字 */
.menu-label {
  font-family: 'Shippori Mincho', serif;
  font-size: 0.85rem;
  color: #888; /* 少し暗めにしてアイコンを目立たせる */
  letter-spacing: 1px;
  text-shadow: 0 0 2px #000;
  transition: 0.3s;
}

/* --- ホバー・タップ時の演出 (アイコン自体を光らせる) --- */
.icon-menu-item:hover .menu-icon-img {
  opacity: 1;
  transform: scale(1.1); /* ふわっと浮く */
  /* 金色に強く発光！ */
  filter: drop-shadow(0 0 10px rgba(212, 175, 55, 0.8)) brightness(1.2);
}

.icon-menu-item:hover .menu-label {
  color: #d4af37;
  text-shadow: 0 0 5px rgba(212, 175, 55, 0.5);
}

/* --- メインアクションボタン（JS制御版） --- */

.action-bar-icons {
  display: flex;
  justify-content: center;
  gap: 50px;
  margin-top: 25px;
  margin-bottom: 20px;
  align-items: flex-start;
}

.action-btn-item {
  display: flex;
  flex-direction: column;
  align-items: center;
  cursor: pointer;
  width: 100px;
  transition: transform 0.2s;
  
  /* スマホでの誤タップ防止 */
  -webkit-tap-highlight-color: transparent;
}

.action-btn-item:active {
  transform: scale(0.95);
}

/* コンテナ（透明） */
.action-circle {
  width: 80px;
  height: 80px;
  background: transparent;
  border: none;
  box-shadow: none;
  display: flex;
  justify-content: center;
  align-items: center;
  transition: 0.3s;
}

/* アイコン画像 */
.action-img {
  width: 64px;
  height: 64px;
  object-fit: contain;
  filter: drop-shadow(0 5px 5px rgba(0,0,0,0.8));
  
  /* ▼▼▼ これが大事！回転をヌルっと動かす設定 ▼▼▼ */
  transition: transform 0.6s cubic-bezier(0.34, 1.56, 0.64, 1);
  /* ▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲ */
}

/* ラベル文字 */
.action-label {
  font-family: 'Shippori Mincho', serif;
  font-size: 0.85rem;
  color: #ccc; 
  letter-spacing: 1px;
  transition: 0.3s;
  text-shadow: 0 0 2px #000;
  margin-top: 5px;
  font-weight: 500;
}

/* --- 個別のスタイル設定（回転は削除、光る演出のみ） --- */

/* 1. 次のラウンド (Next) - 青白く光る */
.action-btn-item:hover .next-circle .action-img {
  filter: drop-shadow(0 0 10px rgba(200, 200, 255, 0.6)) brightness(1.2);
}

/* 2. 封印解除 (Unlock) - 金色に光る */
.action-btn-item:hover .solve-circle .action-img {
  transform: scale(1.15);
  filter: drop-shadow(0 0 15px rgba(212, 175, 55, 0.8)) brightness(1.3);
}

.action-btn-item:hover .action-label {
  color: #fff !important;
  text-shadow: 0 0 8px rgba(255,255,255,0.8);
}



</style>
</head>
<body>
    <div id="title-screen">
      <div class="game-title">OMEGA STONE</div>
    <div style="color:#aaa; margin-bottom:40px; letter-spacing:2px; font-size:0.9rem;">Logical Deduction</div>
    
          <div class="mode-row">
      <div class="btn btn-std" onclick="startGame('easy')"><span>Easy</span><span class="en-font">I</span></div>
      <div id="spacer-easy" class="btn-boost" style="display:none; visibility:hidden; border:none; background:transparent; cursor:default;"></div>
    </div>

    <div class="mode-row">
      <div class="btn btn-hard" style="border-color:#27ae60; color:#abebc6;" onclick="startGame('standard')"><span>Standard</span><span class="en-font">II</span></div>
      <div id="spacer-std" class="btn-boost" style="display:none; visibility:hidden; border:none; background:transparent; cursor:default;"></div>
    </div>

    <div class="mode-row">
      <div class="btn btn-hard" onclick="startGame('hard')"><span>Hard</span><span class="en-font">III</span></div>
      <div id="boost-hard" class="btn-boost" onclick="toggleBoost('hard')" style="display:none;">
  <img src="icon_skull.png" class="boost-img" alt="Boost">
</div>
    </div>

    <div class="mode-row">
      <div class="btn btn-night" onclick="startGame('nightmare')"><span>Nightmare</span><span class="en-font">IV</span></div>
      <div id="boost-nightmare" class="btn-boost" onclick="toggleBoost('nightmare')" style="display:none;">
  <img src="icon_skull.png" class="boost-img" alt="Boost">
</div>
    </div>

    <div class="mode-row">
      <div class="btn btn-chaos" onclick="startGame('chaos')"><span>Chaos</span><span class="en-font">∞</span></div>
      <div id="boost-chaos" class="btn-boost" onclick="toggleBoost('chaos')" style="display:none;">
  <img src="icon_skull.png" class="boost-img" alt="Boost">
</div>
    </div>

    <div class="mode-row">
      <div class="btn btn-omega" onclick="startGame('omega')"><span>Omega</span><span class="en-font">?</span></div>
      <div id="boost-omega" class="btn-boost" onclick="toggleBoost('omega')" style="display:none;">
  <img src="icon_skull.png" class="boost-img" alt="Boost">
</div>
    </div>

    <div id="btn-awakened" class="btn btn-awakened" style="display:none;" onclick="confirmAwakened()">
      <span>Awakened Omega</span><span class="en-font">Ω+</span>
    </div>

        <div class="icon-menu-row">
  
  <div class="icon-menu-item" onclick="startTutorial()">
    <div class="icon-circle">
      <img src="icon_book.png" class="menu-icon-img" alt="Tutorial">
    </div>
    <div class="menu-label">手引き</div>
  </div>

  <div class="icon-menu-item" onclick="showHistory()">
    <div class="icon-circle">
      <img src="icon_scroll.png" class="menu-icon-img" alt="History">
    </div>
    <div class="menu-label">探査の記録</div>
  </div>

  <div class="icon-menu-item" onclick="showInputId()">
    <div class="icon-circle">
      <img src="icon_key.png" class="menu-icon-img" alt="ID">
    </div>
    <div class="menu-label">ID入力</div>
  </div>

</div>



    <div id="loading-indicator">生成中...</div>
  </div>

  <div id="game-screen">
    <div class="hud">
      <div class="hud-left">
        <div class="hud-btn" onclick="openMenuModal()">MENU</div>
         <div class="hud-btn" onclick="showProphecyList()" style="margin-left:5px;">予言書</div>
        <div id="btn-show-result" class="hud-btn" style="display:none; border-color:#2ecc71; color:#2ecc71; font-weight:bold;" onclick="showResult()">RESULT</div>
      </div>
      <div class="mana-bar"><span style="font-size:0.8rem; color:#888;">MANA</span> <span id="ui-mana" class="en-font">0/3</span></div>
    </div>

    <div style="text-align:right; font-size:0.8rem; color:#aaa; margin-top:-15px; margin-bottom:15px; margin-right:5px;">ROUND <span id="ui-round" class="en-font" style="color:#fff; font-size:1.1rem;">1</span></div>

        <div id="chaos-warning" class="chaos-bar">⚠ 常に嘘をつく偽りの予言が1つ含まれています</div>

    <div id="nightmare-warning" class="chaos-bar" style="background: #4a1c8a; border: 1px solid #9b59b6; box-shadow: 0 0 10px #4a1c8a;">
      ⚠ MANAが2に減少 5ラウンド以内に封印を解除する(回答含む)
    </div>


        <div class="rune-container" style="flex-direction:column; gap:5px;">
      <div style="display:flex; justify-content:center; gap:12px;">
        <div class="rune-wrapper">
          <div class="rune-label" style="color:#ff9999">炎<span class="rune-sub">IGNIS</span></div>
          <input type="number" id="r1" class="rune-input" min="1" max="5" placeholder="-" onchange="limitInput(this)">
        </div>
        <div class="rune-wrapper">
          <div class="rune-label" style="color:#99ccff">水<span class="rune-sub">AQUA</span></div>
          <input type="number" id="r2" class="rune-input" min="1" max="5" placeholder="-" onchange="limitInput(this)">
        </div>
        <div class="rune-wrapper">
          <div class="rune-label" style="color:#99ffcc">風<span class="rune-sub">VENTUS</span></div>
          <input type="number" id="r3" class="rune-input" min="1" max="5" placeholder="-" onchange="limitInput(this)">
        </div>
      </div>
      <div id="rune-lock-msg" style="display:none; color:#e74c3c; font-size:0.75rem; font-weight:bold; margin-top:5px; animation:fadeIn 0.5s;">
        🔒️数字は次のラウンドまで変更できません
      </div>
    </div>


    <button class="memo-toggle-btn" onclick="toggleMatrix()">LOGIC MATRIX (Show/Hide)</button>
<div class="logic-grid" id="logic-matrix"></div>

    
        <button class="memo-toggle-btn" onclick="toggleMemoArea()">
  <img src="icon_memo.png" class="memo-icon-img" alt="Memo"> MEMO PAD (Show/Hide)
</button>

    
    <div class="memo-area closed" id="memo-pad">
      <textarea class="memo-textarea" placeholder="推理メモ&#13;&#10;例: 炎は偶数ではない...&#13;&#10;合計は10以上..."></textarea>
    </div>

    <button class="memo-toggle-btn" onclick="toggleProphecyList()">📜 PROPHECY LIST (Show/Hide)</button>
<div id="prophecy-container" class="prophecy-list"></div>


    <div id="omega-rule-area">
      <div class="omega-label">DETECTED LAWS (Search & Destroy)</div>
      <div style="font-size:0.7rem; color:#888; margin-bottom:5px;">※クリックで取り消し線 (メモ)</div>
      <div id="omega-list"></div>
    </div>

    <div class="action-bar-icons">
  
  <div class="action-btn-item" onclick="nextRound()">  
    <div class="action-circle next-circle">
      <img src="icon_next.png" class="action-img" alt="Next">
    </div>
    <div class="action-label">次のラウンドへ</div>
  </div>

  <div class="action-btn-item" onclick="attemptUnlock()">
    <div class="action-circle solve-circle">
      <img src="icon_unlock.png" class="action-img" alt="Unlock">
    </div>
    <div class="action-label" style="color:#d4af37; font-weight:bold;">封印解除</div>
  </div>

</div>


    <div id="log-container" class="log-area">
      <div style="color:#666; text-align:center; font-style:italic; font-size:0.8rem;">-- 解析の記録 --</div>
    </div>
  </div>

    <div id="result-modal" class="modal-overlay">
  <div class="seal-broken">封印解除</div>

  <div id="result-mode-badge" class="en-font" style="font-size:1.5rem; letter-spacing:3px; margin-bottom:15px; font-weight:bold; text-transform:uppercase;"></div>
  <div style="color:#ccc; margin-top:10px;">真実のルーン:</div>

    <div class="answer-reveal" id="final-code"></div>

<div id="user-input-display" style="font-family:'Cinzel', serif; color:#888; font-size:1.1rem; margin-top:-15px; margin-bottom:20px; letter-spacing:2px;">
</div>
    <div id="result-details" style="width:90%; max-width:400px; background:#222; padding:10px; border-radius:8px; margin-bottom:20px; text-align:left; max-height:30vh; overflow-y:auto; border:1px solid #444;"></div>
    
    
    <div style="color:#fff; margin-bottom:20px; font-size:0.9rem;">
      到達ラウンド: <span id="final-round" class="en-font" style="font-size:1.2rem; color:#d4af37; margin-right:15px;"></span>
      総検証数: <span id="final-checks" class="en-font" style="font-size:1.2rem; color:#d4af37;"></span>回
    </div>

    <div style="display:flex; gap:10px; width:90%; max-width:350px;">
      <button class="btn btn-std" style="justify-content:center; flex:1;" onclick="reviewBoard()">盤面を見る</button>
      <button class="btn btn-std" style="justify-content:center; flex:1; background:#d4af37; color:#000; border-color:#fff;" onclick="softResetGame()">次の遺跡へ</button>
    </div>
  </div>


        <div id="id-modal" class="modal-overlay">
    <div style="background:#111; padding:25px 20px; border:1px solid #444; border-radius:12px; width:85%; max-width:320px; box-sizing: border-box;">
      <h3 style="color:#fff; margin-top:0; margin-bottom:15px; font-family:'Shippori Mincho', serif;">石碑IDを入力</h3>
      
      <input type="text" id="input-seed" placeholder="例: A1B2C" 
             style="width:100%; padding:12px; font-size:1.2rem; text-align:center; margin-bottom:20px; 
                    background:#000; border:1px solid #555; border-radius:6px; color:#fff; 
                    font-family:'Cinzel', serif; text-transform:uppercase; box-sizing: border-box;">
      
      <div style="color:#aaa; font-size:0.8rem; margin-bottom:10px; text-align:left;">難易度を選択して開始:</div>
      
      <div style="display:grid; grid-template-columns:1fr 1fr; gap:8px; width:100%; box-sizing: border-box;">
        <button class="btn btn-std" style="width:100% !important; margin:0 !important; padding:10px; font-size:0.85rem; box-sizing: border-box; justify-content:center;" onclick="startFromId('easy')">Easy</button>
        
        <button class="btn btn-hard" style="width:100% !important; margin:0 !important; padding:10px; font-size:0.85rem; border-color:#27ae60; color:#abebc6; box-sizing: border-box; justify-content:center;" onclick="startFromId('standard')">Standard</button>
        
        <button class="btn btn-hard" style="width:100% !important; margin:0 !important; padding:10px; font-size:0.85rem; box-sizing: border-box; justify-content:center;" onclick="startFromId('hard')">Hard</button>
        
        <button class="btn btn-night" style="width:100% !important; margin:0 !important; padding:10px; font-size:0.85rem; box-sizing: border-box; justify-content:center;" onclick="startFromId('nightmare')">Nightmare</button>
        
        <button class="btn btn-chaos" style="width:100% !important; margin:0 !important; padding:10px; font-size:0.85rem; box-sizing: border-box; justify-content:center;" onclick="startFromId('chaos')">Chaos</button>
        
        <button class="btn btn-omega" style="width:100% !important; margin:0 !important; padding:10px; font-size:0.85rem; border:1px solid #fff; box-sizing: border-box; justify-content:center;" onclick="startFromId('omega')">Ω</button>
      </div>
      <button id="btn-id-awakened" class="btn btn-awakened" 
              style="display:none; width:100% !important; margin:10px 0 0 0 !important; padding:12px; font-size:0.9rem; justify-content:center; border-width:2px; box-sizing: border-box;" 
              onclick="startFromId('awakened')">
         Awakened Omega
      </button>
      <button class="btn btn-std" style="margin: 15px 0 0 0 !important; width:100% !important; border-color:#555; color:#aaa; box-sizing: border-box; justify-content:center;" onclick="closeIdModal()">閉じる</button>

    </div>
  </div>

  <div id="history-modal" class="modal-overlay">
    <div id="history-content">
      <div class="close-help" onclick="closeHistory()">×</div>
      <h3 style="color:#fff; margin-top:0; border-bottom:1px solid #333; padding-bottom:10px;">探査の記録</h3>
      <div id="history-list"></div>
    </div>
  </div>
  <div id="tut-overlay"></div> <div id="tut-box" class="tut-msg-box" style="display:none;">
    <div id="tut-text" class="tut-text">ここに説明が入ります</div>
    <div id="tut-pointer" class="tut-arrow" style="display:none;">⬇</div>
    <button id="tut-btn" class="tut-next-btn" onclick="nextTutorialStep()">次へ</button>
  </div>
<script>
// --- LOGIC ENGINE v7.3 (Final Balance) ---

// チュートリアル用の状態変数
let isTutorialMode = false;
let tutStep = 0;

class SeededRandom {
  constructor(seedStr) {
    let h = 2166136261 >>> 0;
    for (let i = 0; i < seedStr.length; i++) {
      h = Math.imul(h ^ seedStr.charCodeAt(i), 16777619);
    }
    this.a = h >>> 0;
  }
  next() {
    let t = this.a += 0x6D2B79F5;
    t = Math.imul(t ^ (t >>> 15), t | 1);
    t ^= t + Math.imul(t ^ (t >>> 7), t | 61);
    return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
  }
}
let rng = null;

// --- 追加するヘルパー関数 ---
function colorize(text) {
  if (!text) return "";
  return text
    .replace(/炎/g, '<span style="color:#ff9999; font-weight:bold;">炎</span>')
    .replace(/水/g, '<span style="color:#99ccff; font-weight:bold;">水</span>')
    .replace(/風/g, '<span style="color:#99ffcc; font-weight:bold;">風</span>');
}

/* diff: 1 -> 簡単 (単一の値、単純な偶奇)
  diff: 2 -> 普通 (2つの比較、単純な合計)
  diff: 3 -> 難しい (3つの関係、複雑な条件、否定形)
*/
const POOL = [
  { name:"炎の偶奇 (偶数, 奇数)", desc:"炎 = 偶数", f:(i,a,v)=>i%2==0, diff:1 }, 
  { name:"炎の偶奇 (偶数, 奇数)", desc:"炎 = 奇数", f:(i,a,v)=>i%2!=0, diff:1 }, 
  { name:"水の偶奇 (偶数, 奇数)", desc:"水 = 偶数", f:(i,a,v)=>a%2==0, diff:1 }, 
  { name:"水の偶奇 (偶数, 奇数)", desc:"水 = 奇数", f:(i,a,v)=>a%2!=0 , diff:1}, 
  { name:"風の偶奇 (偶数, 奇数)", desc:"風 = 偶数", f:(i,a,v)=>v%2==0 , diff:1}, 
  { name:"風の偶奇 (偶数, 奇数)", desc:"風 = 奇数", f:(i,a,v)=>v%2!=0 , diff:1},

    // 炎・水・風と1〜5の関係（<, =, >）
  { name:"炎と1の関係 ( =, >)", desc:"炎 = 1", f:(i,a,v)=>i==1 , diff:1},
  { name:"炎と1の関係 ( =, >)", desc:"炎 > 1", f:(i,a,v)=>i>1 , diff:1},
  { name:"水と1の関係 ( =, >)", desc:"水 = 1", f:(i,a,v)=>a==1, diff:1 },
  { name:"水と1の関係 ( =, >)", desc:"水 > 1", f:(i,a,v)=>a>1 , diff:1},
  { name:"風と1の関係 ( =, >)", desc:"風 = 1", f:(i,a,v)=>v==1, diff:1 },
  { name:"風と1の関係 ( =, >)", desc:"風 > 1", f:(i,a,v)=>v>1, diff:1 },
  
  { name:"炎と2の関係 (<, =, >)", desc:"炎 = 2", f:(i,a,v)=>i==2, diff:1 },
  { name:"炎と2の関係 (<, =, >)", desc:"炎 > 2", f:(i,a,v)=>i>2 , diff:1},
  { name:"炎と2の関係 (<, =, >)", desc:"炎 < 2", f:(i,a,v)=>i<2 , diff:1},
  { name:"水と2の関係 (<, =, >)", desc:"水 = 2", f:(i,a,v)=>a==2, diff:1 },
  { name:"水と2の関係 (<, =, >)", desc:"水 > 2", f:(i,a,v)=>a>2, diff:1 },
  { name:"水と2の関係 (<, =, >)", desc:"水 < 2", f:(i,a,v)=>a<2 , diff:1},
  { name:"風と2の関係 (<, =, >)", desc:"風 = 2", f:(i,a,v)=>v==2, diff:1 },
  { name:"風と2の関係 (<, =, >)", desc:"風 > 2", f:(i,a,v)=>v>2, diff:1 },
  { name:"風と2の関係 (<, =, >)", desc:"風 < 2", f:(i,a,v)=>v<2, diff:1 },

  { name:"炎と3の関係 (<, =, >)", desc:"炎 = 3", f:(i,a,v)=>i==3 , diff:1},
  { name:"炎と3の関係 (<, =, >)", desc:"炎 > 3", f:(i,a,v)=>i>3, diff:1 },
  { name:"炎と3の関係 (<, =, >)", desc:"炎 < 3", f:(i,a,v)=>i<3, diff:1 },
  { name:"水と3の関係 (<, =, >)", desc:"水 = 3", f:(i,a,v)=>a==3, diff:1 },
  { name:"水と3の関係 (<, =, >)", desc:"水 > 3", f:(i,a,v)=>a>3 , diff:1},
  { name:"水と3の関係 (<, =, >)", desc:"水 < 3", f:(i,a,v)=>a<3 , diff:1},
  { name:"風と3の関係 (<, =, >)", desc:"風 = 3", f:(i,a,v)=>v==3 , diff:1},
  { name:"風と3の関係 (<, =, >)", desc:"風 > 3", f:(i,a,v)=>v>3 , diff:1},
  { name:"風と3の関係 (<, =, >)", desc:"風 < 3", f:(i,a,v)=>v<3 , diff:1},

  { name:"炎と4の関係 (<, =, >)", desc:"炎 = 4", f:(i,a,v)=>i==4 , diff:1},
  { name:"炎と4の関係 (<, =, >)", desc:"炎 > 4", f:(i,a,v)=>i>4 , diff:1},
  { name:"炎と4の関係 (<, =, >)", desc:"炎 < 4", f:(i,a,v)=>i<4 , diff:1},
  { name:"水と4の関係 (<, =, >)", desc:"水 = 4", f:(i,a,v)=>a==4, diff:1 },
  { name:"水と4の関係 (<, =, >)", desc:"水 > 4", f:(i,a,v)=>a>4 , diff:1},
  { name:"水と4の関係 (<, =, >)", desc:"水 < 4", f:(i,a,v)=>a<4 , diff:1},
  { name:"風と4の関係 (<, =, >)", desc:"風 = 4", f:(i,a,v)=>v==4 , diff:1},
  { name:"風と4の関係 (<, =, >)", desc:"風 > 4", f:(i,a,v)=>v>4 , diff:1},
  { name:"風と4の関係 (<, =, >)", desc:"風 < 4", f:(i,a,v)=>v<4 , diff:1},

  { name:"炎と5の関係 (<, = )", desc:"炎 = 5", f:(i,a,v)=>i==5 , diff:1},
  { name:"炎と5の関係 (<, = )", desc:"炎 < 5", f:(i,a,v)=>i<5 , diff:1},
  { name:"水と5の関係 (<, = )", desc:"水 = 5", f:(i,a,v)=>a==5, diff:1 },
  { name:"水と5の関係 (<, = )", desc:"水 < 5", f:(i,a,v)=>a<5 , diff:1},
  { name:"風と5の関係 (<, = )", desc:"風 = 5", f:(i,a,v)=>v==5, diff:1 },
  { name:"風と5の関係 (<, = )", desc:"風 < 5", f:(i,a,v)=>v<5, diff:1 },

  { name:"炎と水の比較 (<, =, >)", desc:"炎 > 水", f:(i,a,v)=>i>a, diff:2 }, 
  { name:"炎と水の比較 (<, =, >)", desc:"炎 < 水", f:(i,a,v)=>i<a, diff:2 }, 
  { name:"炎と水の比較 (<, =, >)", desc:"炎 = 水", f:(i,a,v)=>i==a, diff:2 },
  { name:"水と風の比較 (<, =, >)", desc:"水 > 風", f:(i,a,v)=>a>v , diff:2}, 
  { name:"水と風の比較 (<, =, >)", desc:"水 < 風", f:(i,a,v)=>a<v , diff:2}, 
  { name:"水と風の比較 (<, =, >)", desc:"水 = 風", f:(i,a,v)=>a==v , diff:2},
  { name:"炎と風の比較 (<, =, >)", desc:"炎 > 風", f:(i,a,v)=>i>v, diff:2 }, 
  { name:"炎と風の比較 (<, =, >)", desc:"炎 < 風", f:(i,a,v)=>i<v , diff:2}, 
  { name:"炎と風の比較 (<, =, >)", desc:"炎 = 風", f:(i,a,v)=>i==v, diff:2 },

  { name:"最大値の所在 (≧)", desc:"炎が最大 (他以上)", f:(i,a,v)=>i>=a && i>=v, diff:2 }, 
  { name:"最大値の所在 (≧)", desc:"水が最大 (他以上)", f:(i,a,v)=>a>=i && a>=v , diff:2}, 
  { name:"最大値の所在 (≧)", desc:"風が最大 (他以上)", f:(i,a,v)=>v>=i && v>=a, diff:2 }, 
  { name:"最小値の所在 (≦)", desc:"炎が最小 (他以下)", f:(i,a,v)=>i<=a && i<=v, diff:2 }, 
  { name:"最小値の所在 (≦)", desc:"水が最小 (他以下)", f:(i,a,v)=>a<=i && a<=v, diff:2 }, 
  { name:"最小値の所在 (≦)", desc:"風が最小 (他以下)", f:(i,a,v)=>v<=i && v<=a , diff:2}, 

  { name:"合計の偶奇 (偶数, 奇数)", desc:"合計 = 偶数", f:(i,a,v)=>(i+a+v)%2==0 , diff:2},
  { name:"合計の偶奇 (偶数, 奇数)", desc:"合計 = 奇数", f:(i,a,v)=>(i+a+v)%2!=0 , diff:2},
  { name:"合計と6の関係 (<, ≧)", desc:"合計 < 6", f:(i,a,v)=>(i+a+v)<6 , diff:2},
  { name:"合計と6の関係 (<, ≧)", desc:"合計 ≧ 6", f:(i,a,v)=>(i+a+v)>=6 , diff:2},
  { name:"合計と10の関係 (<, ≧)", desc:"合計 < 10", f:(i,a,v)=>(i+a+v)<10 , diff:2},
  { name:"合計と10の関係 (<, ≧)", desc:"合計 ≧ 10", f:(i,a,v)=>(i+a+v)>=10, diff:2 },

  { name:"素数の有無 (あり, なし)", desc:"素数を含む", f:(i,a,v)=>[i,a,v].some(n=>[2,3,5].includes(n)), diff:2 },
  { name:"素数の有無 (あり, なし)", desc:"素数を含まない", f:(i,a,v)=>![i,a,v].some(n=>[2,3,5].includes(n)), diff:2 },

  { name:"炎+水と5の関係 (<, =, >)", desc:"炎+水 > 5", f:(i,a,v)=>(i+a)>5 , diff:3},
  { name:"炎+水と5の関係 (<, =, >)", desc:"炎+水 < 5", f:(i,a,v)=>(i+a)<5  , diff:3},
  { name:"炎+水と5の関係 (<, =, >)", desc:"炎+水 = 5", f:(i,a,v)=>(i+a)==5  , diff:3},
  { name:"水+風と5の関係 (<, =, >)", desc:"水+風 > 5", f:(i,a,v)=>(a+v)>5 , diff:3 },
  { name:"水+風と5の関係 (<, =, >)", desc:"水+風 < 5", f:(i,a,v)=>(a+v)<5  , diff:3},
  { name:"水+風と5の関係 (<, =, >)", desc:"水+風 = 5", f:(i,a,v)=>(a+v)==5 , diff:3 },
  { name:"炎+風と5の関係 (<, =, >)", desc:"炎+風 > 5", f:(i,a,v)=>(i+v)>5  , diff:3},
  { name:"炎+風と5の関係 (<, =, >)", desc:"炎+風 < 5", f:(i,a,v)=>(i+v)<5  , diff:3},
  { name:"炎+風と5の関係 (<, =, >)", desc:"炎+風 = 5", f:(i,a,v)=>(i+v)==5  , diff:3},

  { name:"偶数の数 (0, 1, 2)", desc:"偶数が0個", f:(i,a,v)=>[i,a,v].filter(n=>n%2==0).length==0  , diff:3},
  { name:"偶数の数 (0, 1, 2)", desc:"偶数が1個", f:(i,a,v)=>[i,a,v].filter(n=>n%2==0).length==1 , diff:3 },
  { name:"偶数の数 (0, 1, 2)", desc:"偶数が2個", f:(i,a,v)=>[i,a,v].filter(n=>n%2==0).length==2 , diff:3 },
  { name:"1の数 (0, 1, 2, 3)", desc:"1を含まない", f:(i,a,v)=>[i,a,v].filter(n=>n==1).length==0  , diff:3},
  { name:"1の数 (0, 1, 2, 3)", desc:"1が1個", f:(i,a,v)=>[i,a,v].filter(n=>n==1).length==1  , diff:3},
  { name:"1の数 (0, 1, 2, 3)", desc:"1が2個", f:(i,a,v)=>[i,a,v].filter(n=>n==1).length==2 , diff:3 },
  { name:"1の数 (0, 1, 2, 3)", desc:"1が3個", f:(i,a,v)=>[i,a,v].filter(n=>n==1).length==3 , diff:3 },
  { name:"3の数 (0, 1, 2, 3)", desc:"3を含まない", f:(i,a,v)=>[i,a,v].filter(n=>n==3).length==0 , diff:3 },
  { name:"3の数 (0, 1, 2, 3)", desc:"3が1個", f:(i,a,v)=>[i,a,v].filter(n=>n==3).length==1  , diff:3},
  { name:"3の数 (0, 1, 2, 3)", desc:"3が2個", f:(i,a,v)=>[i,a,v].filter(n=>n==3).length==2 , diff:3 },
  { name:"3の数 (0, 1, 2, 3)", desc:"3が3個", f:(i,a,v)=>[i,a,v].filter(n=>n==3).length==3  , diff:3},
  
  
  { name:"順序の法則 (昇順, 降順, 順不同)", desc:"昇順 (炎 < 水 < 風)", f:(i,a,v)=> (i < a && a < v)  , diff:3},
  { name:"順序の法則 (昇順, 降順, 順不同)", desc:"降順 (炎 > 水 > 風)", f:(i,a,v)=> (i > a && a > v)  , diff:3},
  { name:"順序の法則 (昇順, 降順, 順不同)", desc:"順不同 (バラバラ)", f:(i,a,v)=> !((i < a && a < v) || (i > a && a > v))  , diff:3},


  { name:"隣接する連番の数(0 , 1 , 2)", desc:"隣接する連番の数(0箇所)", f:(i,a,v)=> {
      let c = 0;
      if(Math.abs(i-a) === 1) c++;
      if(Math.abs(a-v) === 1) c++;
      return c === 0;
  } , diff:3},
  { name:"隣接する連番の数(0 , 1 , 2)", desc:"隣接する連番の数(1箇所)", f:(i,a,v)=> {
      let c = 0;
      if(Math.abs(i-a) === 1) c++;
      if(Math.abs(a-v) === 1) c++;
      return c === 1;
  } , diff:3},
  { name:"隣接する連番の数(0 , 1 , 2)", desc:"隣接する連番の数(完全連結)", f:(i,a,v)=> {
      let c = 0;
      if(Math.abs(i-a) === 1) c++;
      if(Math.abs(a-v) === 1) c++;
      return c === 2;
  } , diff:3},
  { name:"2つの同じ数字 (なし, 1組)", desc:"2つの同じ数字はない (すべて異なる)", f:(i,a,v)=> (i!=a && a!=v && i!=v) },
  { name:"2つの同じ数字 (なし, 1組)", desc:"同じ数字が含まれる (ペア or トリオ)", f:(i,a,v)=> {
      return (i===a || a===v || i===v);
  } , diff:3},
  { name:"最大と最小の差(0 ,1 ,2 ,3 ,4)", desc:"最大と最小の差が 0 (すべて同じ)", f:(i,a,v)=> (Math.max(i,a,v) - Math.min(i,a,v)) === 0 , diff:3 },
  { name:"最大と最小の差(0 ,1 ,2 ,3 ,4)", desc:"最大と最小の差が 1 ", f:(i,a,v)=> (Math.max(i,a,v) - Math.min(i,a,v)) === 1 , diff:3 },
  { name:"最大と最小の差(0 ,1 ,2 ,3 ,4)", desc:"最大と最小の差が 2 ", f:(i,a,v)=> (Math.max(i,a,v) - Math.min(i,a,v)) === 2 , diff:3 },
  { name:"最大と最小の差(0 ,1 ,2 ,3 ,4)", desc:"最大と最小の差が 3 ", f:(i,a,v)=> (Math.max(i,a,v) - Math.min(i,a,v)) === 3 , diff:3 },
  { name:"最大と最小の差(0 ,1 ,2 ,3 ,4)", desc:"最大と最小の差が 4 ", f:(i,a,v)=> (Math.max(i,a,v) - Math.min(i,a,v)) === 4 , diff:3 },

  { name:"合計が特定の倍数(2, 3, 5)", desc:"合計が 2の倍数 ", f:(i,a,v)=> (i+a+v)%2 === 0 , diff:3 },
  { name:"合計が特定の倍数(2, 3, 5)", desc:"合計が 3の倍数", f:(i,a,v)=> (i+a+v)%3 === 0  , diff:3},
  { name:"合計が特定の倍数(2, 3, 5)", desc:"合計が 5の倍数", f:(i,a,v)=> (i+a+v)%5 === 0 , diff:3 },

  { name:"合計値が素数かどうか", desc:"合計が素数 (3,5,7,11,13)", f:(i,a,v)=> {
      const sum = i+a+v;
      return [3, 5, 7, 11, 13].includes(sum);
  } , diff:3},
  { name:"合計値が素数かどうか", desc:"合計が素数ではない", f:(i,a,v)=> {
      const sum = i+a+v;
      return ![3, 5, 7, 11, 13].includes(sum);
  } , diff:3},
  // --- ★追加: Diff 4 (Awakened Mode用) ---

  //  1 or 3の個数
  { name:"1か3の数 (0, 1, 2, 3)", desc:"1が0個", f:(i,a,v)=>[i,a,v].filter(n=>n==1).length==0, diff:4 },
  { name:"1か3の数 (0, 1, 2, 3)", desc:"1が1個", f:(i,a,v)=>[i,a,v].filter(n=>n==1).length==1, diff:4 },
  { name:"1か3の数 (0, 1, 2, 3)", desc:"1が2個", f:(i,a,v)=>[i,a,v].filter(n=>n==1).length==2, diff:4 },
  { name:"1か3の数 (0, 1, 2, 3)", desc:"1が3個", f:(i,a,v)=>[i,a,v].filter(n=>n==1).length==3, diff:4 },
  { name:"1か3の数 (0, 1, 2, 3)", desc:"3が0個", f:(i,a,v)=>[i,a,v].filter(n=>n==3).length==0, diff:4 },
  { name:"1か3の数 (0, 1, 2, 3)", desc:"3が1個", f:(i,a,v)=>[i,a,v].filter(n=>n==3).length==1, diff:4 },
  { name:"1か3の数 (0, 1, 2, 3)", desc:"3が2個", f:(i,a,v)=>[i,a,v].filter(n=>n==3).length==2, diff:4 },
  { name:"1か3の数 (0, 1, 2, 3)", desc:"3が3個", f:(i,a,v)=>[i,a,v].filter(n=>n==3).length==3, diff:4 },

  //  2 or 4の個数
  { name:"2か4の数 (0, 1, 2, 3)", desc:"2が0個", f:(i,a,v)=>[i,a,v].filter(n=>n==2).length==0, diff:4 },
  { name:"2か4の数 (0, 1, 2, 3)", desc:"2が1個", f:(i,a,v)=>[i,a,v].filter(n=>n==2).length==1, diff:4 },
  { name:"2か4の数 (0, 1, 2, 3)", desc:"2が2個", f:(i,a,v)=>[i,a,v].filter(n=>n==2).length==2, diff:4 },
  { name:"2か4の数 (0, 1, 2, 3)", desc:"2が3個", f:(i,a,v)=>[i,a,v].filter(n=>n==2).length==3, diff:4 },
  { name:"2か4の数 (0, 1, 2, 3)", desc:"4が0個", f:(i,a,v)=>[i,a,v].filter(n=>n==4).length==0, diff:4 },
  { name:"2か4の数 (0, 1, 2, 3)", desc:"4が1個", f:(i,a,v)=>[i,a,v].filter(n=>n==4).length==1, diff:4 },
  { name:"2か4の数 (0, 1, 2, 3)", desc:"4が2個", f:(i,a,v)=>[i,a,v].filter(n=>n==4).length==2, diff:4 },
  { name:"2か4の数 (0, 1, 2, 3)", desc:"4が3個", f:(i,a,v)=>[i,a,v].filter(n=>n==4).length==3, diff:4 },

  //  唯一の最大値・最小値 (Strict inequality)
  { name:"唯一の最大、最小の所在（最大・最小を複数入れるとFalse）", desc:"炎が唯一の最大 (他より大きい)", f:(i,a,v)=> i > a && i > v, diff:4 },
  { name:"唯一の最大、最小の所在（最大・最小を複数入れるとFalse）", desc:"水が唯一の最大 (他より大きい)", f:(i,a,v)=> a > i && a > v, diff:4 },
  { name:"唯一の最大、最小の所在（最大・最小を複数入れるとFalse）", desc:"風が唯一の最大 (他より大きい)", f:(i,a,v)=> v > i && v > a, diff:4 },
  { name:"唯一の最大、最小の所在（最大・最小を複数入れるとFalse）", desc:"炎が唯一の最小 (他より小さい)", f:(i,a,v)=> i < a && i < v, diff:4 },
  { name:"唯一の最大、最小の所在（最大・最小を複数入れるとFalse）", desc:"水が唯一の最小 (他より小さい)", f:(i,a,v)=> a < i && a < v, diff:4 },
  { name:"唯一の最大、最小の所在（最大・最小を複数入れるとFalse）", desc:"風が唯一の最小 (他より小さい)", f:(i,a,v)=> v < i && v < a, diff:4 },

  //  属性同士の比較 (Diff4枠として再定義)
  // 炎 vs 水
  { name:"炎と特定の属性の比較 (<, =, >)", desc:"炎 > 水", f:(i,a,v)=> i > a, diff:4 },
  { name:"炎と特定の属性の比較 (<, =, >)", desc:"炎 = 水", f:(i,a,v)=> i == a, diff:4 },
  { name:"炎と特定の属性の比較 (<, =, >)", desc:"炎 < 水", f:(i,a,v)=> i < a, diff:4 },
  // 炎 vs 風
  { name:"炎と特定の属性の比較 (<, =, >)", desc:"炎 > 風", f:(i,a,v)=> i > v, diff:4 },
  { name:"炎と特定の属性の比較 (<, =, >)", desc:"炎 = 風", f:(i,a,v)=> i == v, diff:4 },
  { name:"炎と特定の属性の比較 (<, =, >)", desc:"炎 < 風", f:(i,a,v)=> i < v, diff:4 },
  // 水 vs 炎
  { name:"水と特定の属性の比較 (<, =, >)", desc:"水 > 炎", f:(i,a,v)=> a > i, diff:4 },
  { name:"水と特定の属性の比較 (<, =, >)", desc:"水 = 炎", f:(i,a,v)=> a == i, diff:4 },
  { name:"水と特定の属性の比較 (<, =, >)", desc:"水 < 炎", f:(i,a,v)=> a < i, diff:4 },
  // 水 vs 風
  { name:"水と特定の属性の比較 (<, =, >)", desc:"水 > 風", f:(i,a,v)=> a > v, diff:4 },
  { name:"水と特定の属性の比較 (<, =, >)", desc:"水 = 風", f:(i,a,v)=> a == v, diff:4 },
  { name:"水と特定の属性の比較 (<, =, >)", desc:"水 < 風", f:(i,a,v)=> a < v, diff:4 },
  // 風 vs 炎
  { name:"風と特定の属性の比較 (<, =, >)", desc:"風 > 炎", f:(i,a,v)=> v > i, diff:4 },
  { name:"風と特定の属性の比較 (<, =, >)", desc:"風 = 炎", f:(i,a,v)=> v == i, diff:4 },
  { name:"風と特定の属性の比較 (<, =, >)", desc:"風 < 炎", f:(i,a,v)=> v < i, diff:4 },
  // 風 vs 水
  { name:"風と特定の属性の比較 (<, =, >)", desc:"風 > 水", f:(i,a,v)=> v > a, diff:4 },
  { name:"風と特定の属性の比較 (<, =, >)", desc:"風 = 水", f:(i,a,v)=> v == a, diff:4 },
  { name:"風と特定の属性の比較 (<, =, >)", desc:"風 < 水", f:(i,a,v)=> v < a, diff:4 },

  // 2と特定の属性の比較
  { name:"2と特定の属性の比較 (<, =, >)", desc:"2 > 炎", f:(i,a,v)=> 2 > i, diff:4 },
  { name:"2と特定の属性の比較 (<, =, >)", desc:"2 = 炎", f:(i,a,v)=> 2 == i, diff:4 },
  { name:"2と特定の属性の比較 (<, =, >)", desc:"2 < 炎", f:(i,a,v)=> 2 < i, diff:4 },
  { name:"2と特定の属性の比較 (<, =, >)", desc:"2 > 水", f:(i,a,v)=> 2 > a, diff:4 },
  { name:"2と特定の属性の比較 (<, =, >)", desc:"2 = 水", f:(i,a,v)=> 2 == a, diff:4 },
  { name:"2と特定の属性の比較 (<, =, >)", desc:"2 < 水", f:(i,a,v)=> 2 < a, diff:4 },
  { name:"2と特定の属性の比較 (<, =, >)", desc:"2 > 風", f:(i,a,v)=> 2 > v, diff:4 },
  { name:"2と特定の属性の比較 (<, =, >)", desc:"2 = 風", f:(i,a,v)=> 2 == v, diff:4 },
  { name:"2と特定の属性の比較 (<, =, >)", desc:"2 < 風", f:(i,a,v)=> 2 < v, diff:4 },

  // 3と特定の属性の比較
  { name:"3と特定の属性の比較 (<, =, >)", desc:"3 > 炎", f:(i,a,v)=> 3 > i, diff:4 },
  { name:"3と特定の属性の比較 (<, =, >)", desc:"3 = 炎", f:(i,a,v)=> 3 == i, diff:4 },
  { name:"3と特定の属性の比較 (<, =, >)", desc:"3 < 炎", f:(i,a,v)=> 3 < i, diff:4 },
  { name:"3と特定の属性の比較 (<, =, >)", desc:"3 > 水", f:(i,a,v)=> 3 > a, diff:4 },
  { name:"3と特定の属性の比較 (<, =, >)", desc:"3 = 水", f:(i,a,v)=> 3 == a, diff:4 },
  { name:"3と特定の属性の比較 (<, =, >)", desc:"3 < 水", f:(i,a,v)=> 3 < a, diff:4 },
  { name:"3と特定の属性の比較 (<, =, >)", desc:"3 > 風", f:(i,a,v)=> 3 > v, diff:4 },
  { name:"3と特定の属性の比較 (<, =, >)", desc:"3 = 風", f:(i,a,v)=> 3 == v, diff:4 },
  { name:"3と特定の属性の比較 (<, =, >)", desc:"3 < 風", f:(i,a,v)=> 3 < v, diff:4 },

  // 4と特定の属性の比較
  { name:"4と特定の属性の比較 (<, =, >)", desc:"4 > 炎", f:(i,a,v)=> 4 > i, diff:4 },
  { name:"4と特定の属性の比較 (<, =, >)", desc:"4 = 炎", f:(i,a,v)=> 4 == i, diff:4 },
  { name:"4と特定の属性の比較 (<, =, >)", desc:"4 < 炎", f:(i,a,v)=> 4 < i, diff:4 },
  { name:"4と特定の属性の比較 (<, =, >)", desc:"4 > 水", f:(i,a,v)=> 4 > a, diff:4 },
  { name:"4と特定の属性の比較 (<, =, >)", desc:"4 = 水", f:(i,a,v)=> 4 == a, diff:4 },
  { name:"4と特定の属性の比較 (<, =, >)", desc:"4 < 水", f:(i,a,v)=> 4 < a, diff:4 },
  { name:"4と特定の属性の比較 (<, =, >)", desc:"4 > 風", f:(i,a,v)=> 4 > v, diff:4 },
  { name:"4と特定の属性の比較 (<, =, >)", desc:"4 = 風", f:(i,a,v)=> 4 == v, diff:4 },
  { name:"4と特定の属性の比較 (<, =, >)", desc:"4 < 風", f:(i,a,v)=> 4 < v, diff:4 },

//特定同士の比較
// 炎 vs 水
  { name:"特定の属性同士の比較 (<, =, >)", desc:"炎 > 水", f:(i,a,v)=> i > a, diff:4 },
  { name:"特定の属性同士の比較(<, =, >)", desc:"炎 = 水", f:(i,a,v)=> i == a, diff:4 },
  { name:"特定の属性同士の比較(<, =, >)", desc:"炎 < 水", f:(i,a,v)=> i < a, diff:4 },
  // 炎 vs 風
  { name:"特定の属性同士の比較 (<, =, >)", desc:"炎 > 風", f:(i,a,v)=> i > v, diff:4 },
  { name:"特定の属性同士の比較 (<, =, >)", desc:"炎 = 風", f:(i,a,v)=> i == v, diff:4 },
  { name:"特定の属性同士の比較 (<, =, >)", desc:"炎 < 風", f:(i,a,v)=> i < v, diff:4 },
  // 水 vs 炎
  { name:"特定の属性同士の比較 (<, =, >)", desc:"水 > 炎", f:(i,a,v)=> a > i, diff:4 },
  { name:"特定の属性同士の比較 (<, =, >)", desc:"水 = 炎", f:(i,a,v)=> a == i, diff:4 },
  { name:"特定の属性同士の比較 (<, =, >)", desc:"水 < 炎", f:(i,a,v)=> a < i, diff:4 },
  // 水 vs 風
  { name:"特定の属性同士の比較 (<, =, >)", desc:"水 > 風", f:(i,a,v)=> a > v, diff:4 },
  { name:"特定の属性同士の比較 (<, =, >)", desc:"水 = 風", f:(i,a,v)=> a == v, diff:4 },
  { name:"特定の属性同士の比較 (<, =, >)", desc:"水 < 風", f:(i,a,v)=> a < v, diff:4 },
  // 風 vs 炎
  { name:"特定の属性同士の比較 (<, =, >)", desc:"風 > 炎", f:(i,a,v)=> v > i, diff:4 },
  { name:"特定の属性同士の比較 (<, =, >)", desc:"風 = 炎", f:(i,a,v)=> v == i, diff:4 },
  { name:"特定の属性同士の比較 (<, =, >)", desc:"風 < 炎", f:(i,a,v)=> v < i, diff:4 },
  // 風 vs 水
  { name:"特定の属性同士の比較 (<, =, >)", desc:"風 > 水", f:(i,a,v)=> v > a, diff:4 },
  { name:"特定の属性同士の比較 (<, =, >)", desc:"風 = 水", f:(i,a,v)=> v == a, diff:4 },
  { name:"特定の属性同士の比較 (<, =, >)", desc:"風 < 水", f:(i,a,v)=> v < a, diff:4 },

];

let state = { 
  ans:{i:0,a:0,v:0}, rules:[], round:1, mana:0, maxMana:3, 
  liarIndex:-1, stoneCount:5, isOmega:false,
  currentSeed: "", currentMode: "",
  doomLimit: 0 // ラウンド制限(0は無制限)
};

function generateSeed(length) {
  const chars = 'ABCDEFGHJKLMNPQRSTUVWXYZ23456789';
  let result = '';
  for (let i = 0; i < length; i++) {
    result += chars.charAt(Math.floor(Math.random() * chars.length));
  }
  return result;
}

function limitInput(el) {
  if(el.value < 1) el.value = 1;
  if(el.value > 5) el.value = 5;
}

function initMatrix() {
  const grid = document.getElementById('logic-matrix');
  grid.innerHTML = '<div></div>'; 
  for(let n=1; n<=5; n++) grid.innerHTML += `<div class="grid-header">${n}</div>`;
  const rows = [
    {label:"炎", color:"#ff9999", id:"m-i"},
    {label:"水", color:"#99ccff", id:"m-a"},
    {label:"風", color:"#99ffcc", id:"m-v"}
  ];
  rows.forEach(r => {
    grid.innerHTML += `<div class="grid-row-label" style="color:${r.color}">${r.label}</div>`;
    for(let n=1; n<=5; n++) {
      grid.innerHTML += `<div class="grid-cell" id="${r.id}-${n}" onclick="toggleCell(this)"></div>`;
    }
  });
  document.querySelectorAll('.memo-btn').forEach(btn => {
    btn.classList.remove('is-o');
    btn.classList.remove('is-x');
  });
}
function toggleCell(el) {
  if(el.classList.contains('cell-x')) {
    el.classList.remove('cell-x'); el.classList.add('cell-o');
  } else if(el.classList.contains('cell-o')) {
    el.classList.remove('cell-o');
  } else { el.classList.add('cell-x'); }
}
function toggleMemo(el) {
  if(el.classList.contains('is-x')) {
    el.classList.remove('is-x');
  } else if(el.classList.contains('is-o')) {
    el.classList.remove('is-o'); el.classList.add('is-x');
  } else { el.classList.add('is-o'); }
}
function toggleMemoArea() {
  document.getElementById('memo-pad').classList.toggle('closed');
}
function toggleMatrix() {
  const matrix = document.getElementById('logic-matrix');
  matrix.classList.toggle('closed');
}

function toggleProphecyList() {
  const container = document.getElementById('prophecy-container');
  container.classList.toggle('closed');
}



function setBackground(mode) {
    const body = document.body;
    switch(mode) {
        case 'easy':
            // Easy: 静寂の青
            body.style.backgroundImage = "radial-gradient(circle at 50% 50%, #1a252e 0%, #05080a 100%)"; 
            break;
        case 'standard':
            // Standard: 深い森の緑 (ボタンの色に合わせる)
            body.style.backgroundImage = "radial-gradient(circle at 50% 50%, #152e1a 0%, #050a05 100%)"; 
            break;
        case 'hard':
            // Hard: 危険な赤
            body.style.backgroundImage = "radial-gradient(circle at 50% 50%, #3e1a1a 0%, #0a0505 100%)"; 
            break;
        case 'nightmare':
            // Nightmare: 悪夢の紫
            body.style.backgroundImage = "radial-gradient(circle at 50% 50%, #2c1a3e 0%, #08050a 100%)"; 
            break;
        case 'chaos':
            // Chaos: 荒廃した茶色
            body.style.backgroundImage = "radial-gradient(circle at 50% 50%, #3e2723 0%, #000000 100%)"; 
            break;
        case 'omega':
            // Omega: 漆黒と微かな金
            body.style.backgroundImage = "radial-gradient(circle at 50% 50%, #1a1505 0%, #000000 100%)"; 
            break;
        case 'awakened':
            // 覚醒: 血のような赤と黒
            body.style.backgroundImage = "radial-gradient(circle at 50% 50%, #300 0%, #000 100%)";
            break;
           
        default:
            // タイトル画面など
            body.style.backgroundImage = "radial-gradient(circle at 50% 50%, #1a150e 0%, #000000 100%)";
    }
}


 function startGame(mode) {
  isTutorialMode = false;
  let newSeed = generateSeed(5);
  
  // ブーストONなら、IDの末尾に「+」を付ける！
  const isBoosted = boostState[mode] || false;
  if (isBoosted) {
    newSeed += "+";
  }
  
  initGame(mode, newSeed, isBoosted);
}

function startFromId(mode) {
  const input = document.getElementById('input-seed');
  let seed = input.value.trim().toUpperCase();
  if(!seed) { alert("IDを入力してください"); return; }
  closeIdModal();
  
  // ★重要変更: IDのお尻に「+」がついていたら、強制的にブーストONにする
  let isBoosted = boostState[mode] || false;
  
  if (seed.endsWith('+')) {
    isBoosted = true;
    // 「+」がついたままシードとして使うので、通常版とは全く違う乱数が生まれます
  } else if (isBoosted) {
    // UIでブーストONにしているのに「+」がない場合、付けてあげる
    seed += "+";
  }
  
  initGame(mode, seed, isBoosted);
}


// 引数に isBoosted を追加
function initGame(mode, seed, isBoosted = false) {

 // ▼▼▼ ★修正: 未クリアなら「+」を無視して通常モードにする ▼▼▼
  
  // 1. まず「真OMEGA」をクリア済みかチェック
  const isUnlocked = localStorage.getItem('omega_awakened_unlocked') === 'true';

  if (seed && seed.endsWith('+')) {
    if (isUnlocked) {
      // クリア済みなら、正しくブーストON！
      isBoosted = true;
    } else {
      // 未クリアなら、「+」を削除してなかったことにする
      seed = seed.slice(0, -1); 
      isBoosted = false;
    }
  }
  // ▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲
  document.getElementById('loading-indicator').style.display = 'block';

  // (中略: UI初期化系はそのまま)
  document.querySelectorAll('.btn-action').forEach(b => b.style.display = '');
  const manaBar = document.querySelector('.mana-bar');
  if(manaBar) { /*...*/ manaBar.classList.remove('glitch-active'); }
  const roundDisplay = document.getElementById('ui-round');
  if(roundDisplay && roundDisplay.parentNode) { roundDisplay.parentNode.classList.remove('glitch-active'); }
  const oldFrame = document.querySelector('.divine-frame');
  if(oldFrame) oldFrame.remove();
  
  rng = new SeededRandom(seed);
  state.currentSeed = seed;
  state.currentMode = mode;
  
  setTimeout(() => {
    state.round = 1;
    state.mana = 0;
    state.totalChecks = 0;
    
    // パラメータ設定 (変更なし)
    switch(mode) {
      case 'easy': state.maxMana = 3; state.stoneCount = 4; state.doomLimit = 0; break;
      case 'standard': state.maxMana = 3; state.stoneCount = 5; state.doomLimit = 0; break;
      case 'hard': state.maxMana = 3; state.stoneCount = 5; state.doomLimit = 0; break;
      case 'nightmare': state.maxMana = 2; state.stoneCount = 5; state.doomLimit = 5; break;
      case 'chaos': state.maxMana = 3; state.stoneCount = 5; state.doomLimit = 0; break;
      case 'omega': state.maxMana = 3; state.stoneCount = 5; state.doomLimit = 0; break;
      case 'awakened': state.maxMana = 3; state.stoneCount = 5; state.doomLimit = 0; break;
    }
    state.isOmega = (mode === 'omega' || mode === 'awakened');

    const resultBtn = document.getElementById('btn-show-result');
    if(resultBtn) resultBtn.style.display = 'none';
    
    let success = false;
    let attempts = 0;
    const maxAttempts = 20000; 
    
    while(!success && attempts < maxAttempts) {
      attempts++;
      state.ans = {
        i: Math.floor(rng.next()*5)+1,
        a: Math.floor(rng.next()*5)+1,
        v: Math.floor(rng.next()*5)+1
      };
      
      let picked = [];

      // 共通Helper: ランダム抽出関数
      const pickFromPool = (pool, count, currentPicked) => {
           let candidates = [...pool];
           for (let k = candidates.length - 1; k > 0; k--) {
               const j = Math.floor(rng.next() * (k + 1));
               [candidates[k], candidates[j]] = [candidates[j], candidates[k]];
           }
           let selected = [];
           for(let r of candidates) {
             if(selected.length >= count) break;
             const totalList = [...currentPicked, ...selected];
             if(totalList.some(p => p.name === r.name)) continue;
             if(isConflict(totalList, r)) continue;
             selected.push(r);
           }
           return selected;
      };


      // ★★★ 生成ロジック分岐 ★★★
      
      if (mode === 'awakened') {
        // --- Awakened (元々のDiff4モード) ---
        const allValid = POOL.filter(r => r.f(state.ans.i, state.ans.a, state.ans.v) === true);
        const poolD2 = allValid.filter(r => (r.diff||1) === 2);
        const poolD3 = allValid.filter(r => (r.diff||1) === 3);
        const poolD4 = allValid.filter(r => (r.diff||1) === 4);

        if(poolD2.length < 1 || poolD3.length < 1 || poolD4.length < 3) continue;

        const p2 = pickFromPool(poolD2, 1, picked); if(p2.length < 1) continue; picked.push(...p2);
        const p3 = pickFromPool(poolD3, 1, picked); if(p3.length < 1) continue; picked.push(...p3);
        const p4 = pickFromPool(poolD4, 3, picked); if(p4.length < 3) continue; picked.push(...p4);

      } else {
        // --- 通常モード (Easy, Std, Hard, Night, Chaos, Omega) ---
        
        let minDiff = 1;
        let maxDiff = 3;
        if (mode === 'easy') maxDiff = 2;
        if (mode === 'hard' || mode === 'nightmare' || mode === 'omega') minDiff = 2;

        const allValid = POOL.filter(r => r.f(state.ans.i, state.ans.a, state.ans.v) === true);

        // ★★★ ブースト判定 (Diff4 を 1つ混ぜる) ★★★
        if (isBoosted) {
           // 1. Diff4のプールを作成
           const poolD4 = allValid.filter(r => (r.diff||1) === 4);
           // Diff4が足りない(条件に合うものがない)なら生成失敗してやり直し
           if (poolD4.length === 0) continue; 
           
           // 2. Diff4から1つ選ぶ
           const p4 = pickFromPool(poolD4, 1, picked);
           if (p4.length < 1) continue;
           picked.push(...p4);
           
           // 残りの枠 (stoneCount - 1)
           // 既存の「minDiff〜maxDiff」の範囲で選ぶ
        }

        // --- 残りのルールを選出 ---
        let normalPool = allValid.filter(r => {
           let d = r.diff || 1;
           if(d < minDiff || d > maxDiff) return false;
           return true;
        });
        
        // 足りなければやり直し
        if (normalPool.length < (state.stoneCount - picked.length)) continue;

        const needed = state.stoneCount - picked.length;
        const pNormal = pickFromPool(normalPool, needed, picked);
        
        if (pNormal.length < needed) continue;
        picked.push(...pNormal);
      }
      
      // (以下、解の一意性チェックなどは変更なし)
      // 解の一意性検証
      let matches = 0;
      for(let i=1; i<=5; i++) {
        for(let a=1; a<=5; a++) {
          for(let v=1; v<=5; v++) {
             if(picked.every(rule => rule.f(i,a,v))) matches++;
          }
        }
      }

      if(matches === 1) {
        if(mode === 'chaos') {
          // Chaos: 嘘つき判定ロジック
          const trueLiar = Math.floor(rng.next() * state.stoneCount);
          let solutionsForTrueLiar = countSolutionsWithLiar(picked, trueLiar);

          if(solutionsForTrueLiar === 1) {
            let isAmbiguous = false;
            for(let otherLiar = 0; otherLiar < state.stoneCount; otherLiar++) {
              if(otherLiar === trueLiar) continue; 
              let solutionsForOther = countSolutionsWithLiar(picked, otherLiar);
              if(solutionsForOther === 1) {
                isAmbiguous = true; break; 
              }
            }
            if(!isAmbiguous) {
              state.rules = picked; state.liarIndex = trueLiar; success = true;
            }
          }
        } else {
          state.rules = picked; state.liarIndex = -1; success = true;
        }
      }
    }

    document.getElementById('loading-indicator').style.display = 'none';

    if(!success) {
      alert("生成失敗: 再試行します。");
    } else {
      // 成功時処理 (変更なし)
      document.getElementById('title-screen').style.display = 'none';
      const tutBtn = document.getElementById('top-tut-btn');
      if(tutBtn) tutBtn.style.display = 'none';

      document.getElementById('game-screen').style.display = 'block';
      setBackground(mode);
      updateHUD();
      document.getElementById('log-container').innerHTML = '';
      
      const hud = document.querySelector('.hud');
      const oldId = document.getElementById('current-id-display');
      if(oldId) oldId.remove();
      
      // ★修正: ブースト中はIDの横にマークを付けるなどしても良いかも？
      const boostMark = isBoosted ? ' <span style="color:#ff0000; font-weight:bold;"><br><img src="icon_skull.png" class="boost-img img-danger" alt="skull"></span>' : '';
      
      hud.insertAdjacentHTML('afterend', 
        `<div id="current-id-display" style="text-align:center; color:#555; font-size:0.7rem; margin-top:-10px;">ID: <span style="font-family:'Cinzel',serif; color:#777;">${state.currentSeed}</span>${boostMark}</div>`
      );

      document.getElementById('omega-rule-area').style.display = state.isOmega ? 'block' : 'none';

      initMatrix();
      renderProphecies();

      const chaosWarn = document.getElementById('chaos-warning');
      if (mode === 'chaos') {
        if(chaosWarn) { chaosWarn.style.display = 'none'; chaosWarn.classList.remove('visible'); }
        executeChaosIntro();
      } else {
        if(chaosWarn) chaosWarn.style.display = 'none';
      }

      const nmWarn = document.getElementById('nightmare-warning');
      if(nmWarn) { nmWarn.style.display = 'none'; nmWarn.classList.remove('visible'); }

      if (mode === 'nightmare') {
        executeNightmareIntro();
      }
    }
  }, 100);
}



// ヘルパー関数: 指定した石碑が嘘つきだと仮定した場合の解の個数を数える
function countSolutionsWithLiar(rules, liarIdx) {
  let count = 0;
  for(let i=1; i<=5; i++) {
    for(let a=1; a<=5; a++) {
      for(let v=1; v<=5; v++) {
         let validCount = 0;
         rules.forEach((r, idx) => {
           let res = r.f(i, a, v);
           if(idx === liarIdx) res = !res; // こいつが嘘つきだと反転
           if(res) validCount++;
         });
         // 全てのルールを満たすならカウント
         if(validCount === rules.length) count++;
      }
    }
  }
  return count;
}


// ▼▼▼ 演出用関数 ▼▼▼
async function executeNightmareIntro() {
  const slash = document.getElementById('nightmare-slash');
  const manaBar = document.querySelector('.mana-bar');
  const roundDisplay = document.getElementById('ui-round').parentNode;

  // 1. 一瞬の静寂と暗転
  document.body.style.filter = "brightness(0.5)";
  
  // 2. 斬撃！！
  if(slash) {
    slash.style.display = 'block';
    setTimeout(() => { 
        slash.style.display = 'none'; 
        document.body.style.filter = ""; 
    }, 200);
  }

  // 3. マナとラウンドを「破壊」して書き換える
  if(manaBar) manaBar.classList.add('glitch-active');
  if(roundDisplay) roundDisplay.classList.add('glitch-active');

  setTimeout(() => {
    // マナを3から2へ強制改変する視覚演出
    const uiMana = document.getElementById('ui-mana');
    const uiRound = document.getElementById('ui-round');

    if(uiMana) uiMana.innerHTML = '<span style="text-decoration:line-through; color:#555;">3</span> 0/2';
    if(uiRound) uiRound.innerText = "1 / 5";
    
    // 4. 演出終了、色を禍々しく
    setTimeout(() => {
      if(manaBar) {
          manaBar.classList.remove('glitch-active');
          manaBar.style.color = "#ff0000";
          manaBar.style.textShadow = "0 0 10px #ff0000";
      }
      if(roundDisplay) roundDisplay.classList.remove('glitch-active');
      
      // ▼▼▼ ★追加: 警告文をじわっと出す処理 ▼▼▼
      const nmWarn = document.getElementById('nightmare-warning');
      if(nmWarn) {
        nmWarn.style.display = 'block'; // まず枠を作る
        setTimeout(() => {
           nmWarn.classList.add('visible'); // じわっと不透明度を上げる
        }, 100);
      }
      // ▲▲▲▲▲▲▲▲▲▲

    }, 1000);
  }, 500);
}


function executeChaosIntro() {
  const stones = document.querySelectorAll('.stone');
  const warningBar = document.getElementById('chaos-warning');
  
  // 警告文を一旦隠す（念のため）
  if(warningBar) warningBar.classList.remove('visible');

  stones.forEach((stone, index) => {
    // 石碑の位置を取得
    const rect = stone.getBoundingClientRect();
    const centerX = rect.left + rect.width / 2;
    const topY = rect.top + window.scrollY; // スクロール考慮

    // 呪いのオーブを生成
    const orb = document.createElement('div');
    orb.className = 'chaos-orb';
    document.body.appendChild(orb);

    // オーブの開始位置（画面上部）と終了位置を設定
    // アニメーションで制御するため、CSS変数で落差を渡す手もありますが、
    // ここではシンプルにWeb Animations APIを使います
    
    orb.style.left = (centerX - 10) + 'px'; // -10はオーブの半径
    orb.style.top = (topY - 500) + 'px'; // かなり上から

    // 落下アニメーション
    // ランダムな遅延を入れてバラバラ落ちてくるようにする
    const delay = index * 200; 
    const duration = 800;

    const animation = orb.animate([
      { transform: 'translateY(0) scale(1.5)', opacity: 0 },
      { transform: 'translateY(500px) scale(1)', opacity: 1 } // 500px落下して着弾
    ], {
      duration: duration,
      delay: delay,
      easing: 'cubic-bezier(0.5, 0, 1, 1)', // 加速しながら落ちる
      fill: 'forwards'
    });

    // 着弾時の処理
    setTimeout(() => {
      orb.remove(); // オーブ消滅
      stone.classList.add('chaos-infected'); // 石碑が感染！
      
      // SEがあればここで再生
    }, delay + duration);
  });

  // 全てが着弾した後に、警告文をじわっと表示
  setTimeout(() => {
    if(warningBar) {
      // 1. まず「透明な状態で」箱を出現させる
      warningBar.style.display = 'block'; 
      
      // 2. ブラウザが箱を描画するのをほんの少し(0.1秒)待つ
      setTimeout(() => {
        // 3. その後、クラスをつけてフェードイン開始！
        warningBar.classList.add('visible');
      }, 100); 
    }
  }, 1500); // 着弾待ち時間
}


// グローバル変数: 現在選択中のメモ欄を記憶する
let activeOmegaInput = null;

function renderProphecies() {
  const c = document.getElementById('prophecy-container');
  c.innerHTML = '';
  const names = ["α", "β", "γ", "δ", "ε"];
  
  // --- 1. Omegaモードのリスト表示部分 ---
  if (state.isOmega) {
    const listContainer = document.getElementById('omega-list');
    listContainer.innerHTML = '';
    
    // シャッフル表示
    let displayRules = [...state.rules];
    displayRules.sort(() => Math.random() - 0.5); 

    displayRules.forEach((r,idx) => {
      const item = document.createElement('div');
      item.className = 'omega-list-item';
      item.innerHTML = colorize(r.name);
      
      const delay = 3000 + (idx * 100); 
      item.classList.add('falling');
      item.style.animationDelay = `${delay}ms`;
      
      setTimeout(() => {
        item.style.animation = 'none'; 
        item.style.opacity = '1'; 
        item.style.transform = 'translateY(0) scale(1)';
      }, delay + 3500);
      
      item.onmousedown = (e) => {
        if(activeOmegaInput) {
          e.preventDefault(); 
        }
      };

      item.onclick = () => {
        if (activeOmegaInput) {
          const currentText = activeOmegaInput.value;
          const newText = r.name.split(' (')[0]; 
          if(currentText) {
             activeOmegaInput.value = currentText + ", " + newText;
          } else {
             activeOmegaInput.value = newText;
          }
        } else {
          item.classList.toggle('excluded'); 
        }
      };
      listContainer.appendChild(item);
    });
  }

  // --- 2. 石碑の生成部分 ---
  state.rules.forEach((r, idx) => {
    // ラッパー作成
    let wrapper = document.createElement('div');
    let div = document.createElement('div');
    
    if (state.isOmega) {
      div.className = 'stone is-mystery';
      div.classList.add('stone-fall'); 
      div.style.animationDelay = `${idx * 0.2}s`; 
      div.style.justifyContent = "space-between"; 
      
      // ★修正ポイント: 落下が終わったら、落下クラスを消して「光るクラス」をつける！
      div.onanimationend = () => {
        div.classList.remove('stone-fall');
        div.classList.add('omega-pulsing'); // ← これで光り始めます！
        div.style.opacity = 1; 
        div.style.transform = 'translateY(0)';
      };
      
      div.id = `stone-${idx}`;
      div.innerHTML = `
        <div class="stone-content">
          <div class="stone-title" style="display:block; color:#888;">予言 ${names[idx]}</div>
          <div class="stone-text" style="font-size:1.8rem; letter-spacing:3px;">???</div>
        </div>
        <div class="stone-id" style="color:#444;">${names[idx]}</div>
      `;
    } else {
      div.className = 'stone';
      div.id = `stone-${idx}`;
      div.innerHTML = `
        <div class="stone-content">
          <div class="stone-title">予言 ${names[idx]}</div>
          <div class="stone-text">${colorize(r.name)}</div> 
        </div>
        <div class="stone-id">${names[idx]}</div>
      `;
    }

    div.onclick = () => checkProphecy(idx, r, div);
    wrapper.appendChild(div);

    // Ωモードならメモ欄とコピーボタンを追加
    if (state.isOmega) {
      const memoBox = document.createElement('div');
      memoBox.className = 'omega-memo-box';
      
      const input = document.createElement('input');
      input.type = 'text';
      input.className = 'omega-memo-input';
      input.placeholder = `予言${names[idx]} のメモ`;
      
      input.onfocus = () => { activeOmegaInput = input; };
      input.onblur = () => { 
        setTimeout(() => {
          if(activeOmegaInput === input) activeOmegaInput = null;
        }, 200);
      };
      
            const copyBtn = document.createElement('div');
      copyBtn.className = 'btn-omega-copy';
          // ▼▼▼ SVGで「青く光るクリスタル風のコピーアイコン」を描画 ▼▼▼
      // 形状はわかりやすい「重なる四角」ですが、色と発光で魔法っぽくしています
      copyBtn.innerHTML = `
        <svg width="18" height="18" viewBox="0 0 24 24" fill="none" 
             stroke="#99ccff" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"
             style="pointer-events: none; filter: drop-shadow(0 0 3px #99ccff);">
          <rect x="9" y="9" width="13" height="13" rx="2" ry="2" style="opacity: 0.6;"></rect>
          <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path>
        </svg>
      `;
      // ▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲
      
      copyBtn.title = "内容をコピー";
      
      copyBtn.onclick = () => {
        if(!input.value) return;
        navigator.clipboard.writeText(input.value).then(() => {
          // コピー成功時の演出（一瞬チェックマークにする）
          const originalHTML = copyBtn.innerHTML; // 元の画像を記憶
          
          copyBtn.innerHTML = '✔'; // チェックマークは文字でOK、または画像にしてもOK
          copyBtn.classList.add('copy-success');
          
          setTimeout(() => {
            copyBtn.innerHTML = originalHTML; // 元の画像に戻す
            copyBtn.classList.remove('copy-success');
          }, 1500);
        });
      };

      memoBox.appendChild(input);
      memoBox.appendChild(copyBtn);
      wrapper.appendChild(memoBox);
    }

    c.appendChild(wrapper);
  });
}


// ▼▼▼ 高速化修正: 正規表現を定数として外に出す ▼▼▼
const CONFLICT_REGEX = /^(.+)と\d+の関係/;

function isConflict(pickedList, newRule) {
  // キャッシュした正規表現を使う（ここが高速化の肝！）
  const matchNew = newRule.name.match(CONFLICT_REGEX);
  if(matchNew) {
    const key = matchNew[1]; 
    return pickedList.some(p => {
       const matchP = p.name.match(CONFLICT_REGEX);
       return matchP && matchP[1] === key;
    });
  }
  return false;
}


function checkProphecy(idx, rule, el) {
  // チュートリアル制御
  if(isTutorialMode && tutStep !== 6 && tutStep !== 12 && tutStep !== 15 && tutStep !== 18) return;
  
  // マナ切れチェック
  if(state.mana >= state.maxMana) return;
  
  // 入力チェック
  const i = +document.getElementById('r1').value;
  const a = +document.getElementById('r2').value;
  const v = +document.getElementById('r3').value;
  if(!i || !a || !v) return;
  
  // 最初の判定時にロック＆メッセージ表示
  if(state.mana === 0) {
    document.getElementById('r1').disabled = true;
    document.getElementById('r2').disabled = true;
    document.getElementById('r3').disabled = true;
    const msg = document.getElementById('rune-lock-msg');
    if(msg) msg.style.display = 'block';
  }

  // 判定ロジック
  let isTrue = rule.f(i, a, v);
  if(idx === state.liarIndex) isTrue = !isTrue;

  // マナ消費と更新
  state.mana++;
  state.totalChecks++; 
  updateHUD();
  
  // 石碑を即座に無効化
  if(el) el.classList.add('disabled'); 

  // ▼▼▼ 演出開始！ ▼▼▼
  const popup = document.getElementById('judge-text');
  
  // 色と文字の設定
  if (isTrue) {
    popup.innerText = "TRUE";
    popup.style.color = "#d4af37"; // 金色
    popup.style.textShadow = "0 0 20px #d4af37";
  } else {
    popup.innerText = "FALSE";
    popup.style.color = "#9b59b6"; // 紫色
    popup.style.textShadow = "0 0 20px #9b59b6";
  }

  // アニメーション1: 出現
  popup.className = "en-font anim-pop-in";

  // 1秒後にログへ移動するアニメーション
  setTimeout(() => {
    popup.className = "en-font anim-drop-down";
    
    // さらに0.4秒後（吸い込まれた直後）にログへ追加
    setTimeout(() => {
      addLogEntry(idx, rule, isTrue, i, a, v);
      // ポップアップをリセット
      popup.style.opacity = 0;
      popup.className = "en-font";
    }, 400);

  }, 1000); // ★ここで1秒溜めます
  
  // マナ切れ時の石碑無効化
  if(state.mana >= state.maxMana) {
    document.querySelectorAll('.stone').forEach(s => s.classList.add('disabled'));
  }
}

// ▼▼▼ ログ追加処理を切り出した関数 ▼▼▼
function addLogEntry(idx, rule, isTrue, i, a, v) {
  const log = document.getElementById('log-container');
  const entry = document.createElement('div');
  const names = ["α", "β", "γ", "δ", "ε"];
  
  // クラスによる配色はCSS側で制御
  entry.className = isTrue ? 'log-entry log-true' : 'log-entry log-false';
  
  // ふわっと出現させるアニメーション追加
  entry.style.animation = "fadeIn 0.5s";

  const numsHtml = `
    <span class="num-fire">${i}</span>-<span class="num-water">${a}</span>-<span class="num-wind">${v}</span>
  `;

  entry.innerHTML = `
    <div style="width:100%;">
      <div style="display:flex; justify-content:space-between; align-items:center;">
        <span style="font-weight:bold;">R${state.round} 予言${names[idx]}</span>
        <strong>${isTrue ? "TRUE" : "FALSE"}</strong>
      </div>
      <div style="font-size:0.85rem; margin:4px 0; color:rgba(255,255,255,0.7); padding-left:8px; border-left:2px solid rgba(255,255,255,0.1);">
        ${state.isOmega ? "???" : colorize(rule.name)}
      </div>
      <div style="text-align:right;">
        <span class="log-nums" style="background:#000; padding:2px 8px; border-radius:4px; font-family:'Cinzel',serif;">${numsHtml}</span>
      </div>
    </div>
  `;
  
  // ログの一番上に追加
  log.prepend(entry);
}


function nextRound() {
  // マナが残っているのに押した場合（通常時のみ無効化）
  if(state.mana === 0 && !isTutorialMode) return;
  
  // --- チュートリアル中の特別処理 ---
  if(isTutorialMode) {
    // ステップ9（ラウンド終了指示）の時だけ許可
    if(tutStep === 9) {
    
      spinNextIcon();
      state.round++;
      state.mana = 0;
      updateHUD();
      performRoundReset();
      nextTutorialStep(); // 次のステップへ
    }
    return;
  }

  // --- 通常時の処理 ---
  
  // ナイトメアモード等の「死の宣告」チェック
  if(state.doomLimit > 0 && state.round >= state.doomLimit) {
    finishGame(false, "遺跡崩壊");
    return;
  }
  
  spinNextIcon();
  state.round++;
  state.mana = 0;
  updateHUD();
  performRoundReset();
}

// ラウンド切り替え時の「お掃除」
function performRoundReset() {
  const r1 = document.getElementById('r1');
  const r2 = document.getElementById('r2');
  const r3 = document.getElementById('r3');
  
  // 1. 入力ロックを解除
  r1.disabled = false;
  r2.disabled = false;
  r3.disabled = false;
  
  // 3. 「ロック中」の警告メッセージを消す！
  const msg = document.getElementById('rune-lock-msg');
  if(msg) msg.style.display = 'none'; 

  // 4. 石碑のグレーアウトを解除
  document.querySelectorAll('.stone').forEach(s => s.classList.remove('disabled'));
  
}

function attemptUnlock() {
  const i = +document.getElementById('r1').value;
  const a = +document.getElementById('r2').value;
  const v = +document.getElementById('r3').value;
  const isCorrect = (i === state.ans.i && a === state.ans.a && v === state.ans.v);
  
  finishGame(isCorrect);
}

// 終了処理
function finishGame(isWin, titleOverride) {
  // 入力値を取得しておく
  const uI = document.getElementById('r1').value;
  const uA = document.getElementById('r2').value;
  const uV = document.getElementById('r3').value;
  const omegaArea = document.getElementById('omega-rule-area');
  if(omegaArea) omegaArea.style.display = 'none';
   const modal = document.getElementById('result-modal');
  modal.style.display = 'flex';
  
   const modeBadge = document.getElementById('result-mode-badge');
  if(modeBadge) {
    // 基本のモード名 (EASY, HARD etc)
    let modeText = state.currentMode.toUpperCase();
    
    // もしIDのお尻に「+」がついていたら（＝ブースト状態なら）、表示にも「+」を足す！
    if (state.currentSeed && state.currentSeed.endsWith('+')) {
      modeText += "+";
    }
    
    // 画面にセット
    modeBadge.innerText = modeText;

    // モードごとの色設定
    let mColor = "#fff"; // デフォルト
    let mGlow = "#fff";
    
        switch(state.currentMode) {
      case 'easy':     mColor = "#3498db"; mGlow = "#2980b9"; break; // 青
      case 'standard': mColor = "#27ae60"; mGlow = "#2ecc71"; break; // 緑
      case 'hard':     mColor = "#e74c3c"; mGlow = "#c0392b"; break; // 赤
      case 'nightmare':mColor = "#9b59b6"; mGlow = "#8e44ad"; break; // 紫
      case 'chaos':    mColor = "#d35400"; mGlow = "#a04000"; break; // ★変更: 茶色/焦げ茶
      case 'omega':    mColor = "#fff";    mGlow = "#d4af37"; break; // 白＆金
    }

    modeBadge.style.color = mColor;
    modeBadge.style.textShadow = `0 0 15px ${mGlow}`;
  }
  
  // ★追加: Ωモードクリア時の神演出
  if (isWin && state.isOmega) {
    const frame = document.createElement('div');
    frame.className = 'divine-frame';
    document.body.appendChild(frame);
  }
  const title = document.querySelector('.seal-broken');
  if(isWin) {
    title.innerText = "封印解除";
    title.style.color = "#fff";
  } else {
    title.innerText = titleOverride || "解除失敗";
    title.style.color = "#c0392b";
  }
  
  document.getElementById('final-code').innerText = `${state.ans.i} ${state.ans.a} ${state.ans.v}`;
   // ▼▼▼ 追加: ユーザー入力値の表示 ▼▼▼
  const userDisplay = document.getElementById('user-input-display');
  if(userDisplay) {
    userDisplay.innerHTML = `YOUR CODE: <span style="color:${isWin ? '#fff' : '#e74c3c'}; border-bottom:1px solid #555;">${uI} ${uA} ${uV}</span>`;
  }
  
  document.getElementById('final-round').innerText = state.round;
  
  // ★追加: 検証回数を表示 (存在チェック付き)
  const checksEl = document.getElementById('final-checks');
  if(checksEl) checksEl.innerText = state.totalChecks;

  saveHistory(isWin, {i:uI, a:uA, v:uV});

  const detailBox = document.getElementById('result-details');
  let html = '';
  const names = ["α", "β", "γ", "δ", "ε"];
  state.rules.forEach((r, idx) => {
      const isLiar = (idx === state.liarIndex);
      const liarTag = isLiar ? '<span class="res-liar-txt">[嘘つき]</span> ' : '';
      html += `<div class="res-row">
        <div><strong>予言${names[idx]}</strong>: ${liarTag}${r.name}</div>
        <div style="color:#d4af37; padding-left:10px; font-size:0.85rem;">
           👉 正解の法則: <strong>${r.desc}</strong>
        </div>
      </div>`;
  });
  detailBox.innerHTML = html;
}

// ブースト状態を管理するオブジェクト
let boostState = {
  hard: false,
  nightmare: false,
  chaos: false,
  omega: false
};

// ★修正: 閉じカッコ不足を修正し、横並びクラスの付け替えを実装
function checkAwakenedUnlock() {
  const isUnlocked = localStorage.getItem('omega_awakened_unlocked') === 'true';
  const btn = document.getElementById('btn-awakened');
  
  // Awakenedボタン制御
  if(btn) btn.style.display = isUnlocked ? 'flex' : 'none';

  // ブーストボタン（ドクロ）制御
  ['hard', 'nightmare', 'chaos', 'omega'].forEach(m => {
    const bBtn = document.getElementById(`boost-${m}`);
    if(bBtn) bBtn.style.display = isUnlocked ? 'flex' : 'none';
  });

  // ★追加修正: EasyとStandardの「透明スペーサー」も連動させる
  // これにより、ドクロが出ている時だけ、Easy/Stdも幅を合わせて縮みます
  const spacerEasy = document.getElementById('spacer-easy');
  const spacerStd = document.getElementById('spacer-std');
  
  if(spacerEasy) spacerEasy.style.display = isUnlocked ? 'flex' : 'none';
  if(spacerStd) spacerStd.style.display = isUnlocked ? 'flex' : 'none';
  
  
}


// ブースト切り替え & 演出
function toggleBoost(mode) {
  boostState[mode] = !boostState[mode]; // ON/OFF反転
  
  const boostBtn = document.getElementById(`boost-${mode}`);
  
  if(boostState[mode]) {
    boostBtn.classList.add('active');
    
    // ★追加: じんわり警告メッセージを出す
    // ブーストボタンの隣にある「難易度ボタン」を探す
    const parentRow = boostBtn.parentElement;
    const modeBtn = parentRow.querySelector('.btn'); // 兄弟要素のボタン
    
    if(modeBtn) {
      // 既存のポップアップがあれば消す
      const oldMsg = modeBtn.querySelector('.boost-popup');
      if(oldMsg) oldMsg.remove();

      // メッセージ作成
      const msg = document.createElement('div');
      msg.className = 'boost-popup';
      
      // モード名を大文字で取得 (例: HARD)
      const modeName = mode.charAt(0).toUpperCase() + mode.slice(1);
      msg.innerText = `${modeName} 難易度上昇`;
      
      modeBtn.appendChild(msg);

      // アニメーションが終わったら消す
      setTimeout(() => {
        if(msg.parentNode) msg.remove();
      }, 2600);
    }

  } else {
    boostBtn.classList.remove('active');
  }
}

// ▼▼▼ 履歴システム完全版 (ここからコピー) ▼▼▼

// 1. 履歴を保存する関数 (ログとメモも保存)
function saveHistory(isWin, userInput) {
  if (isTutorialMode) return;
  
  // 覚醒モード解放チェック
  if (state.currentMode === 'omega' && isWin) {
    if (localStorage.getItem('omega_awakened_unlocked') !== 'true') {
        localStorage.setItem('omega_awakened_unlocked', 'true');
        setTimeout(() => { playUnlockAnimation(); }, 500);
    }
  }

  // 現在のログHTMLとメモの内容を取得
  const logHtml = document.getElementById('log-container') ? document.getElementById('log-container').innerHTML : "";
  const memoText = document.querySelector('.memo-textarea') ? document.querySelector('.memo-textarea').value : "";

  const historyItem = {
    seed: state.currentSeed,
    mode: state.currentMode,
    round: state.round,
    win: isWin,
    date: new Date().toLocaleString(),
    ans: state.ans,     // 正解
    input: userInput,   // ユーザーの入力
    logs: logHtml,      // ログデータ
    memo: memoText      // メモデータ
  };
  
  let history = JSON.parse(localStorage.getItem('omega_history') || '[]');
  history.unshift(historyItem);
  if(history.length > 30) history.pop();
  localStorage.setItem('omega_history', JSON.stringify(history));
}

// 2. 履歴リストを表示する関数
function showHistory() {
  const tutBtn = document.getElementById('top-tut-btn');
  if(tutBtn) tutBtn.style.display = 'none';

  const modal = document.getElementById('history-modal');
  const list = document.getElementById('history-list');
  const history = JSON.parse(localStorage.getItem('omega_history') || '[]');
  
  modal.style.display = 'flex';
  list.innerHTML = '';
  
  if(history.length === 0) {
    list.innerHTML = '<div style="color:#666; text-align:center; padding:20px;">記録なし</div>';
    return;
  }

  // ★ここが重要: (h, idx) でインデックスを受け取る
  history.forEach((h, idx) => {
    const item = document.createElement('div');
    item.className = 'hist-item';
    let modeLabel = h.mode.toUpperCase();
    if(h.mode==='standard') modeLabel = 'STD';
    if(h.mode==='nightmare') modeLabel = 'NIGHT';
    
    // 詳細情報の生成
    let detailHtml = "";
    if (h.ans && h.input) {
       const inputColor = h.win ? '#2ecc71' : '#e74c3c';
       detailHtml = `
         <div style="font-size:0.75rem; color:#aaa; margin-top:8px; border-top:1px dashed #333; padding-top:4px; display:flex; justify-content:space-between;">
           <span>正解: <span style="color:#d4af37; font-weight:bold;">${h.ans.i}-${h.ans.a}-${h.ans.v}</span></span>
           <span>入力: <span style="color:${inputColor}; font-weight:bold;">${h.input.i}-${h.input.a}-${h.input.v}</span></span>
         </div>
       `;
    }
    
    // ボタンに idx を渡す: onclick="openReview(${idx})"
    item.innerHTML = `
      <div class="hist-left" style="width:100%;">
        <div style="display:flex; justify-content:space-between; align-items:flex-start;">
            <div>
                <span class="hist-mode mode-${h.mode}">${modeLabel}</span>
                <span class="hist-id">#${h.seed}</span>
            </div>
            <div style="display:flex; align-items:center;">
                <span class="hist-result ${h.win ? 'res-win':'res-lose'}" style="margin-right:8px;">${h.win ? 'WIN':'LOSE'}</span>
                
                <button class="btn-replay" onclick="openReview(${idx})" style="border-color:#aaa; color:#eee; cursor:pointer;">
                  🔍 記録
                </button>
            </div>
        </div>
        <div class="hist-date" style="margin-top:2px;">${h.date} - R${h.round}</div>
        ${detailHtml}
      </div>
    `;
    list.appendChild(item);
  });
}

// 3. 詳細画面を開く関数 (これが抜けていました！)
function openReview(idx) {
  const history = JSON.parse(localStorage.getItem('omega_history') || '[]');
  const h = history[idx];
  if(!h) return;

  // 履歴一覧を閉じて詳細を開く
  document.getElementById('history-modal').style.display = 'none';
  const modal = document.getElementById('review-modal');
  modal.style.display = 'flex';

  // ヘッダー情報
  const modeLabel = h.mode.toUpperCase();
  const headerEl = document.getElementById('review-header');
  if(headerEl) {
      headerEl.innerHTML = `
        <span><span class="hist-mode mode-${h.mode}">${modeLabel}</span> #${h.seed}</span>
        <span>${h.date}</span>
      `;
  }

  // 正解と入力
  const resultBox = document.getElementById('review-answer-box');
  if(resultBox) {
      if(h.ans && h.input) {
        const winColor = h.win ? '#2ecc71' : '#e74c3c';
        resultBox.innerHTML = `
          <div style="display:flex; justify-content:space-around; align-items:center; font-family:'Cinzel', serif;">
            <div>
              <div style="font-size:0.7rem; color:#888;">CORRECT</div>
              <div style="font-size:1.2rem; color:#d4af37;">${h.ans.i} - ${h.ans.a} - ${h.ans.v}</div>
            </div>
            <div style="font-size:1.5rem; color:#555;">➡</div>
            <div>
              <div style="font-size:0.7rem; color:#888;">YOUR INPUT</div>
              <div style="font-size:1.2rem; color:${winColor}; text-decoration:underline;">${h.input.i} - ${h.input.a} - ${h.input.v}</div>
            </div>
          </div>
          <div style="margin-top:5px; font-weight:bold; color:${winColor}; font-size:0.9rem;">
            RESULT: ${h.win ? 'WIN (封印解除)' : 'LOSE (解除失敗)'}
          </div>
        `;
      } else {
        resultBox.innerHTML = '<span style="color:#666;">詳細データなし</span>';
      }
  }

  // メモの復元
  const memoArea = document.getElementById('review-memo');
  if(memoArea) memoArea.value = h.memo || "(メモなし)";

  // ログの復元
  const logArea = document.getElementById('review-log');
  if(logArea) {
      if(h.logs) {
        logArea.innerHTML = h.logs;
      } else {
        logArea.innerHTML = '<div style="color:#666; padding:10px;">ログデータなし</div>';
      }
  }
}

// 4. 詳細画面を閉じる関数
function closeReview() {
  const modal = document.getElementById('review-modal');
  if(modal) modal.style.display = 'none';
  // 履歴一覧に戻る
  const histModal = document.getElementById('history-modal');
  if(histModal) histModal.style.display = 'flex';
}

// ▲▲▲ 履歴システムここまで ▲▲▲


// ▼▼▼ 追加関数: 履歴詳細を開く ▼▼▼
function openReview(idx) {
  const history = JSON.parse(localStorage.getItem('omega_history') || '[]');
  const h = history[idx];
  if(!h) return;

  // 履歴一覧を一旦閉じる（重なるので）
  document.getElementById('history-modal').style.display = 'none';

  const modal = document.getElementById('review-modal');
  modal.style.display = 'flex';

  // 1. ヘッダー情報
  const modeLabel = h.mode.toUpperCase();
  document.getElementById('review-header').innerHTML = `
    <span><span class="hist-mode mode-${h.mode}">${modeLabel}</span> #${h.seed}</span>
    <span>${h.date}</span>
  `;

  // 2. 正解と入力の表示
  const resultBox = document.getElementById('review-answer-box');
  if(h.ans && h.input) {
    const winColor = h.win ? '#2ecc71' : '#e74c3c';
    resultBox.innerHTML = `
      <div style="display:flex; justify-content:space-around; align-items:center; font-family:'Cinzel', serif;">
        <div>
          <div style="font-size:0.7rem; color:#888;">CORRECT</div>
          <div style="font-size:1.2rem; color:#d4af37;">${h.ans.i} - ${h.ans.a} - ${h.ans.v}</div>
        </div>
        <div style="font-size:1.5rem; color:#555;">➡</div>
        <div>
          <div style="font-size:0.7rem; color:#888;">YOUR INPUT</div>
          <div style="font-size:1.2rem; color:${winColor}; text-decoration:underline;">${h.input.i} - ${h.input.a} - ${h.input.v}</div>
        </div>
      </div>
      <div style="margin-top:5px; font-weight:bold; color:${winColor}; font-size:0.9rem;">
        RESULT: ${h.win ? 'WIN (封印解除)' : 'LOSE (解除失敗)'}
      </div>
    `;
  } else {
    resultBox.innerHTML = '<span style="color:#666;">詳細データなし</span>';
  }

  // 3. メモの復元
  const memoArea = document.getElementById('review-memo');
  memoArea.value = h.memo || "(メモなし)";

  // 4. ログの復元
  const logArea = document.getElementById('review-log');
  if(h.logs) {
    logArea.innerHTML = h.logs;
  } else {
    logArea.innerHTML = '<div style="color:#666; padding:10px;">ログデータなし</div>';
  }
}

function closeReview() {
  document.getElementById('review-modal').style.display = 'none';
  // 履歴一覧に戻る
  document.getElementById('history-modal').style.display = 'flex';
}
// ▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲


function startFromHistory(mode, seed) {
  closeHistory();
  initGame(mode, seed);
}

function reviewBoard() {
  document.getElementById('result-modal').style.display = 'none';
  const resultBtn = document.getElementById('btn-show-result');
  if(resultBtn) resultBtn.style.display = 'flex';
  
  document.getElementById('r1').disabled = true;
  document.getElementById('r2').disabled = true;
  document.getElementById('r3').disabled = true;
  document.querySelectorAll('.stone').forEach(s => s.classList.add('disabled'));
  document.querySelectorAll('.btn-action').forEach(b => b.style.display = 'none');

  if(state.liarIndex !== -1) {
      const liarStone = document.getElementById(`stone-${state.liarIndex}`);
      if(liarStone) liarStone.classList.add('is-liar');
  }
  
  if(state.isOmega) {
      const names = ["α", "β", "γ", "δ", "ε"];
      state.rules.forEach((r, idx) => {
          const s = document.getElementById(`stone-${idx}`);
          if(s) {
              s.innerHTML = `
                <div style="font-size:0.7rem; color:#aaa;">${names[idx]}</div>
                <div style="font-size:0.9rem; color:#fff;">${r.name}</div>
              `;
              s.style.background = "#222";
              s.style.border = "1px solid #777";
          }
      });
  }
}

function showResult() { document.getElementById('result-modal').style.display = 'flex'; }
function updateHUD() {
  // 制限がある場合 "1 / 5" のように表示
  const roundText = (state.doomLimit > 0) ? `${state.round} / ${state.doomLimit}` : state.round;
  document.getElementById('ui-round').innerText = roundText;
  document.getElementById('ui-mana').innerText = `${state.mana}/${state.maxMana}`;
}
// ガイド表示関数（×ボタン削除・理解したボタン版）
function showHelp() {
  const modal = document.getElementById('help-modal');
  modal.style.display = 'flex';
  
  // HTML生成用の変数
  let difficultyHtml = '';
  const mode = state.currentMode || 'standard';

  // --- 1. 難易度別の特別ルール ---
  if (mode === 'nightmare') {
    difficultyHtml = `
      <div class="help-section" style="border-color:#9b59b6; background:rgba(44, 26, 62, 0.4);">
        <div class="help-title" style="color:#d7bde2;">★ NIGHTMAREのルール</div>
        <div class="help-text">
          <ul>
            <li><strong>死の宣告:</strong> <span style="color:#ff5555;">封印解除を含めて5ラウンド</span>経過でゲームオーバー。</li>
            <li><strong>魔力枯渇:</strong> 1ラウンドのマナは <span style="color:#ff5555;">2つ</span> のみ。</li>
          </ul>
        </div>
      </div>`;
  } else if (mode === 'chaos') {
    difficultyHtml = `
      <div class="help-section" style="border-color:#95a5a6; background:rgba(50,50,50,0.4);">
        <div class="help-title" style="color:#ccc;">★ CHAOS (混沌) のルール</div>
        <div class="help-text">
          <ul>
            <li><strong>嘘つき:</strong> 石碑の中に1つだけ<span style="color:#ff5555;">「判定を逆にする嘘つき」</span>が混ざっています。</li>
            <li>矛盾を見抜いて、嘘つきを特定してください。</li>
          </ul>
        </div>
      </div>`;
  } else if (mode === 'omega') {
    difficultyHtml = `
      <div class="help-section" style="border-color:#fff; background:rgba(0,0,0,0.6);">
        <div class="help-title" style="color:#fff;">★ OMEGA (Ω) のルール</div>
        <div class="help-text">
          <ul>
            <li><strong>不可視:</strong> 全ての予言の内容が <span style="color:#fff;">???</span> です。</li>
            <li>右下のリストから、適用されているルールを推理してください。</li>
          </ul>
        </div>
      </div>`;
  } else if (mode === 'hard') {
     difficultyHtml = `
      <div class="help-section" style="border-color:#e74c3c; background:rgba(62, 26, 26, 0.4);">
        <div class="help-title" style="color:#f5b7b1;">★ HARD (高難度) のルール</div>
        <div class="help-text">
          「炎=1」のような単純なヒントが出現にくく、<br>
          計算や比較が必要な、手ごわい予言が登場しやすいです。
        </div>
      </div>`;
  }

  // --- 2. 共通ガイド ---
  const contentHtml = `
    <h2 style="text-align:center; margin-top:0; color:#fff; border-bottom:1px solid #333; padding-bottom:10px;">遺跡解析マニュアル</h2>
    
    ${difficultyHtml}

    <div class="help-section">
      <div class="help-title">1. ゲームの目的</div>
      <div class="help-text">
        隠された正解の数字（<span style="color:#ff9999">炎</span>・<span style="color:#99ccff">水</span>・<span style="color:#99ffcc">風</span> それぞれ1〜5）を特定することです。<br>
        いきなり当てるのは無理なので、<strong>「予言の石碑」</strong>に質問をして、少しずつ絞り込みます。
      </div>
    </div>

    <div class="help-section">
      <div class="help-title">2. 解析の流れ (図解)</div>
      <div class="help-text">
        例えば、ある石碑に<strong>「合計と10の関係」</strong>というルールが書かれていたとします。
      </div>

      <div class="diagram-box">
        <div style="width:100%; text-align:left; font-size:0.8rem; color:#aaa; margin-bottom:5px;">▼ STEP 1: 仮の数字をセット</div>
        <div style="display:flex; gap:5px; justify-content:center; margin-bottom:10px;">
          <div style="border:1px solid #8a1c1c; color:#ff9999; padding:5px 10px; border-radius:4px;">炎: 4</div>
          <div style="border:1px solid #1c4e8a; color:#99ccff; padding:5px 10px; border-radius:4px;">水: 5</div>
          <div style="border:1px solid #1c8a5e; color:#99ffcc; padding:5px 10px; border-radius:4px;">風: 2</div>
        </div>
        <div style="font-size:0.8rem; color:#fff;">合計 = <strong>11</strong> の状態です。</div>
      </div>

      <div style="text-align:center; font-size:1.5rem; color:#d4af37; margin:-10px 0;">⬇</div>

      <div class="diagram-box">
        <div style="width:100%; text-align:left; font-size:0.8rem; color:#aaa; margin-bottom:5px;">▼ STEP 2: 石碑に判定させる</div>
        <div class="d-stone" style="width:95%;">
          <span>予言β: 合計と10の関係</span>
          <span style="font-weight:bold;">判定 ▶</span>
        </div>
        <div style="margin:5px 0;">もし、結果がこう出たら…？</div>
        <div class="d-result d-true" style="padding:10px; width:80%; text-align:center;">TRUE (真実)</div>
      </div>

      <div class="diagram-box" style="border-color:#d4af37; background:rgba(212, 175, 55, 0.1);">
        <div style="width:100%; text-align:left; font-size:0.8rem; color:#d4af37; font-weight:bold; margin-bottom:5px;">▼ STEP 3: 推理</div>
        <div class="help-text" style="font-size:0.85rem;">
          「合計11」で「TRUE」が出た。<br>
          → つまりこの石碑は<strong>「合計 ≧ 10」</strong>のルールだと推測できます。<br>
          (もし「合計＜10」ならFALSEになるはずだからです)
        </div>
      </div>
    </div>

    <div class="help-section" style="border-bottom:none;">
      <div class="help-title">3. メモを活用せよ</div>
      <div class="help-text">
        マトリクス表をタップしてメモを取り、可能性を絞り込んでいきましょう。
      </div>
    </div>

    <button class="btn btn-std" style="width:100%; box-sizing:border-box; margin-top:10px; padding:15px; font-weight:bold; font-size:1.1rem; border-color:#d4af37; color:#d4af37;" onclick="closeHelp()">理解した！</button>
  `;

  const contentDiv = document.getElementById('help-content');
  contentDiv.innerHTML = contentHtml;
}

  // --- TUTORIAL LOGIC v2 ---
function startTutorial() {
  if (typeof colorize !== 'function') {
    window.colorize = function(t) { return t; };
  }

  isTutorialMode = true;
  tutStep = 0;
  
  const tutBtn = document.getElementById('top-tut-btn');
  if(tutBtn) tutBtn.style.display = 'none';
  
  const loader = document.getElementById('loading-indicator');
  if(loader) loader.style.display = 'block';
  
  document.getElementById('title-screen').style.display = 'none';
  document.getElementById('game-screen').style.display = 'block';
  
  // --- レイアウト変更 & QUITボタン追加 ---
  try {
    const txt = document.getElementById('tut-text');
    if(txt) txt.innerHTML = '<div style="text-align:center; color:#888;">システム起動中...</div>';

    // QUITボタンの存在確認と作成
    let quitBtn = document.getElementById('tut-quit-btn');
    const tutBox = document.getElementById('tut-box');
    if (tutBox && !quitBtn) {
      quitBtn = document.createElement('button');
      quitBtn.id = 'tut-quit-btn';
      quitBtn.innerText = "中断する";
      quitBtn.style.cssText = "position:absolute; top:10px; right:10px; background:transparent; border:1px solid #555; color:#888; font-size:0.7rem; padding:4px 8px; border-radius:4px; cursor:pointer;";
      quitBtn.onclick = quitTutorial;
      tutBox.appendChild(quitBtn);
    }
    if(quitBtn) quitBtn.style.display = 'block';

    // マトリクス非表示などは既存通り
    const matrix = document.getElementById('logic-matrix');
    if(matrix) matrix.style.display = 'none';
    const memoBtn = document.querySelector('.memo-toggle-btn');
    if(memoBtn) memoBtn.style.display = 'none';
    const memoPad = document.getElementById('memo-pad');
    if(memoPad) memoPad.style.display = 'none';
    const runeContainer = document.querySelector('.rune-container');
    if(runeContainer) {
       const matrixLabel = runeContainer.nextElementSibling;
       if(matrixLabel && matrixLabel.innerText && matrixLabel.innerText.includes('LOGIC')) {
          matrixLabel.style.display = 'none';
       }
    }

    // BOX移動
    const gameScreen = document.getElementById('game-screen');
    const prophecyContainer = document.getElementById('prophecy-container');
    if (gameScreen && tutBox && prophecyContainer) {
      gameScreen.insertBefore(tutBox, prophecyContainer);
      tutBox.classList.add('tut-embedded-mode');
      tutBox.style.display = 'flex';
    }
  } catch(e) { console.error("Layout Setup Error:", e); }
  
  setTimeout(() => {
    try {
      state.round = 1;
      state.mana = 0;
      state.totalChecks = 0;
      state.maxMana = 3; 
      state.stoneCount = 4; // ★変更: 4つにする
      
      // ★変更: 正解を 4-4-5 に設定 (風=5のルールと整合させるため)
      state.ans = { i:4, a:4, v:5 }; 
      
      state.liarIndex = -1;
      state.isOmega = false;
      
      state.rules = [
        { name:"炎と水の比較 (<, =, >)", desc:"炎 = 水", f:(i,a,v)=>i==a },
        { name:"合計と10の関係 (<, ≧)", desc:"合計 ≧ 10", f:(i,a,v)=>(i+a+v)>=10 },
        { name:"風と5の関係 (<, = )", desc:"風 = 5", f:(i,a,v)=>v==5 },
        { name:"炎の偶奇 (偶数, 奇数)", desc:"炎 = 偶数", f:(i,a,v)=>i%2==0 }
      ];
      
      setBackground('standard');
      updateHUD();
      
      const logContainer = document.getElementById('log-container');
      if(logContainer) logContainer.innerHTML = '';
      
      const chaosWarn = document.getElementById('chaos-warning');
      if(chaosWarn) chaosWarn.style.display = 'none';
      const omegaArea = document.getElementById('omega-rule-area');
      if(omegaArea) omegaArea.style.display = 'none';
      
      initMatrix();
      const matrix = document.getElementById('logic-matrix');
      if(matrix) matrix.style.display = 'none';
      
      const c = document.getElementById('prophecy-container');
      if(c) {
        c.innerHTML = '';
        const names = ["α", "β", "γ", "δ"]; // δを追加
        state.rules.forEach((r, idx) => {
          let div = document.createElement('div');
          div.className = 'stone';
          div.id = `stone-${idx}`;
          div.innerHTML = `
            <div class="stone-content">
              <div class="stone-title">予言 ${names[idx]}</div>
              <div class="stone-text">${colorize(r.name)}</div>
            </div>
            <div class="stone-id">${names[idx]}</div>
          `;
          div.onclick = () => { if(isTutorialMode) handleTutClick('stone', idx); };
          c.appendChild(div);
        });
      }

      document.getElementById('r1').value = "";
      document.getElementById('r2').value = "";
      document.getElementById('r3').value = "";

      nextTutorialStep(); 
    } catch(e) {
      alert("Tutorial Error: " + e);
    } finally {
      if(loader) loader.style.display = 'none';
    }
  }, 500);
}

// 数字を順番に入力する演出関数
function typeNumber(n1, n2, n3, callback) {
  const r1 = document.getElementById('r1');
  const r2 = document.getElementById('r2');
  const r3 = document.getElementById('r3');
  
  // 入力欄が見つからない場合のエラー回避
  if(!r1 || !r2 || !r3) {
    console.error("エラー: 入力欄(r1, r2, r3)が見つかりません");
    if(callback) callback(); // 無理やり次へ進める
    return;
  }
  
  // 値をリセット
  r1.value = ""; r2.value = ""; r3.value = "";
  
  // リズムよく入力 (0.7秒, 1.2秒, 1.6秒後)
  setTimeout(() => { r1.value = n1; }, 700);
  setTimeout(() => { r2.value = n2; }, 1200);
  setTimeout(() => { r3.value = n3; }, 1600);
  
  // 全て終わった後にコールバックを実行 (3秒後)
  setTimeout(() => {
    if(callback) callback();
  }, 3000);
}

function handleTutClick(type, idx) {
  // ステップ6: 石碑α
  if(tutStep === 6 && type === 'stone' && idx === 0) {
    checkProphecy(0, state.rules[0], document.getElementById('stone-0'));
    nextTutorialStep(); 
  }
  // ステップ12: 石碑β
  if(tutStep === 12 && type === 'stone' && idx === 1) {
    checkProphecy(1, state.rules[1], document.getElementById('stone-1'));
    nextTutorialStep(); 
  }
  // ステップ15: 石碑γ
  if(tutStep === 15 && type === 'stone' && idx === 2) {
    checkProphecy(2, state.rules[2], document.getElementById('stone-2'));
    nextTutorialStep(); 
  }
  // ★追加 ステップ18: 石碑δ
  if(tutStep === 18 && type === 'stone' && idx === 3) {
    checkProphecy(3, state.rules[3], document.getElementById('stone-3'));
    nextTutorialStep(); 
  }
}


const originalAttemptUnlock = attemptUnlock;
// ★修正: チュートリアル完了時に本番アニメーションを実行する
attemptUnlock = function() {
  if(isTutorialMode) {
    // 終了ステップ 22
    if(tutStep === 22) {
      // 1. チュートリアル表示のお掃除
      document.querySelectorAll('.tut-highlight').forEach(e => e.classList.remove('tut-highlight'));
      document.querySelectorAll('.tut-blink').forEach(e => e.classList.remove('tut-blink'));
      
      const quitBtn = document.getElementById('tut-quit-btn');
      if(quitBtn) quitBtn.style.display = 'none';

      const tutBox = document.getElementById('tut-box');
      if(tutBox) {
        tutBox.style.display = 'none';
        tutBox.classList.remove('tut-embedded-mode');
        document.body.appendChild(tutBox); 
      }
      document.getElementById('tut-overlay').style.display = 'none';
      
      // UI復帰 (マトリクスなどを再表示)
      const matrix = document.getElementById('logic-matrix');
      if(matrix) matrix.style.display = '';
      const memoBtn = document.querySelector('.memo-toggle-btn');
      if(memoBtn) memoBtn.style.display = '';
      const memoPad = document.getElementById('memo-pad');
      if(memoPad) memoPad.style.display = '';
      const runeContainer = document.querySelector('.rune-container');
      if(runeContainer) {
          const matrixLabel = runeContainer.nextElementSibling;
          if(matrixLabel) matrixLabel.style.display = '';
      }

      // 2. ★ここを変更: いきなり本番用アニメーション関数を呼ぶ！
      // (通常は確認画面から呼ばれますが、直接呼んでも動きます)
      executeUnlock();

      // 3. アニメーション(約2.3秒)が終わってリザルトが出た頃にメッセージを出す
      setTimeout(() => {
         alert("おめでとう！\nチュートリアルは完了だ。\nさあ、本番の遺跡へ挑もう！");
         // アラートを閉じたら終了処理
         quitTutorial();
      }, 4000);
    }
  } else {
    // --- 通常モード (変更なし) ---
    const i = document.getElementById('r1').value;
    const a = document.getElementById('r2').value;
    const v = document.getElementById('r3').value;
    
    const omegaArea = document.getElementById('omega-rule-area');
    if(omegaArea) omegaArea.style.display = 'none';

    if(!i || !a || !v) {
      alert("数字が入力されていません！");
      if(state.isOmega && omegaArea) omegaArea.style.display = 'block';
      return;
    }

    document.getElementById('confirm-nums').innerText = `${i} - ${a} - ${v}`;
    document.getElementById('confirm-modal').style.display = 'flex';
  }
};

function nextTutorialStep() {
  tutStep++;
  const txt = document.getElementById('tut-text');
  const btn = document.getElementById('tut-btn');
  
  // リセット
  document.querySelectorAll('.tut-highlight').forEach(e => e.classList.remove('tut-highlight'));
  document.querySelectorAll('.tut-blink').forEach(e => e.classList.remove('tut-blink'));
  document.getElementById('tut-overlay').style.display = 'block'; 
  
  btn.style.display = 'block'; 
  btn.innerText = "次へ ▶";

  const cFire = '<span style="color:#ff9999; font-weight:bold;">炎</span>';
  const cWater = '<span style="color:#99ccff; font-weight:bold;">水</span>';
  const cWind = '<span style="color:#99ffcc; font-weight:bold;">風</span>';

  switch(tutStep) {
    case 1:
      txt.innerHTML = `ようこそ、探求者よ。<br>
      このゲームの目的は<b>「答えが1つに絞られる、3桁の数字（1〜5まで）」</b>を特定することだ！<br>
      まずは画面右上を見てほしい。<br>
      ここには現在の<b>「ラウンド数」</b>が刻まれている。<br>
      一度セットした数字はラウンド終了まで変更できないぞ。`;
      const uiRound = document.getElementById('ui-round');
      if(uiRound && uiRound.parentNode) uiRound.parentNode.classList.add('tut-highlight', 'tut-blink');
      break;

    case 2:
      txt.innerHTML = `そしてその上が<b>「マナ」</b>だ。<br>
      石碑に問いかけるたびに 1 消費する。<br>
      マナが尽きると、回復するために次のラウンドに進むしかなくなる。`;
      const manaBar = document.querySelector('.mana-bar');
      if(manaBar) manaBar.classList.add('tut-highlight', 'tut-blink');
      break;

    case 3:
      txt.innerHTML = `では、調査を始めよう。<br>
      石碑に<b>「質問」</b>をして法則を暴き、隠された<b>「3つの数字」</b>を特定していこう。`;
      break;
      
    case 4:
      txt.innerHTML = `下にあるのが<b>「予言の石碑」</b>だ。<br>
      これらは正解の数字に関する「ある法則」を知っている。<br>まずはこれらに注目してほしい。`;
      const pContainer = document.getElementById('prophecy-container');
      if(pContainer) pContainer.classList.add('tut-highlight', 'tut-blink'); 
      break;

    case 5:
      txt.innerHTML = `上の入力欄を使って、石碑に質問を投げかける。<br>
      試しに<b>「1 - 1 - 1」</b>という数字をセットしてみよう。<br>
      (${cFire}:1, ${cWater}:1, ${cWind}:1 という意味だ)`;
      
      const runeBox = document.querySelector('.rune-container');
      if(runeBox) runeBox.classList.add('tut-highlight', 'tut-blink');
      btn.style.display = 'none';
      
      setTimeout(() => {
        if (typeof typeNumber !== 'function') {
           document.getElementById('r1').value = 1; document.getElementById('r2').value = 1; document.getElementById('r3').value = 1;
           btn.style.display = 'block'; btn.innerText = "OK"; return;
        }
        typeNumber(1, 1, 1, () => {
             txt.innerHTML = `よし。「1 - 1 - 1」とセット完了だ。<br>
             これで石碑に聞く準備が整った。`;
             btn.style.display = 'block'; btn.innerText = "OK";
        });
      }, 500);
      break;
      
    case 6:
      txt.innerHTML = `「もし正解が 1-1-1 だったら、お前の法則を満たすか？」<br>
      一番上の<b>「予言 α」</b>にそう聞いてみよう。<br>
      タップして判定を行え。`;
      const s0 = document.getElementById('stone-0');
      if(s0) s0.classList.add('tut-highlight', 'tut-blink');
      btn.style.display = 'none'; 
      break;

    case 7: 
      const logTrue = `
        <div class="log-entry log-true" style="margin-top:10px; text-align:left;">
          <div style="width:100%;">
            <div style="display:flex; justify-content:space-between; align-items:center;">
              <span style="font-weight:bold;">R1 予言α</span> <strong>TRUE</strong>
            </div>
            <div style="font-size:0.85rem; margin:4px 0; color:#ddd; padding-left:8px; border-left:2px solid rgba(255,255,255,0.2);">
              ${colorize("炎と水の比較 (<, =, >)")}
            </div>
            <div style="text-align:right;"><span class="log-nums">1-1-1</span></div>
          </div>
        </div>`;
      txt.innerHTML = `石碑の反応があったぞ！<br>${logTrue}<br>「1-1-1」は条件（${cFire} = ${cWater}）を満たしているため <b>TRUE</b> となったのだ。`;
      document.getElementById('log-container').classList.add('tut-highlight');
      break;

    case 8:
      txt.innerHTML = `これで「${cFire}と${cWater}が同じ」とわかった。<br>
      さて、別の数字を試したいところだが…<br>
      <b>一度セットした数字(1-1-1)は、このラウンド中は変更できない。</b>`;
      break;

    case 9:
      txt.innerHTML = `新しい数字を試すには、時間を進める必要がある。<br>
      左下の<b>「次のラウンドへ」</b>ボタンを押してくれ。<br>
      （ラウンドが進むとマナも回復するぞ）`;
      // 丸(circle)を見つけて、その親の「ボタン本体(.action-btn-item)」を取得する
const nextBtn = document.querySelector('.next-circle').closest('.action-btn-item');
      if(nextBtn) nextBtn.classList.add('tut-highlight', 'tut-blink');
      btn.style.display = 'none'; // ユーザーがボタンを押すのを待つ
      break;

    case 10:
      txt.innerHTML = `よし！ <b>ラウンド2</b> に突入した。<br>
      これで入力欄のロックが解除され、再び自由に数字をセットできる。<br>
      さあ、検証の続きだ。`;
      document.getElementById('ui-round').parentNode.classList.add('tut-highlight');
      break;

    case 11:
      txt.innerHTML = `次は合計がとても小さい<b>「1 - 1 - 2」</b>（合計4）を入力しよう。`;
      const runeBox2 = document.querySelector('.rune-container');
      if(runeBox2) runeBox2.classList.add('tut-highlight', 'tut-blink');
      btn.style.display = 'none';
      setTimeout(() => {
        if (typeof typeNumber !== 'function') {
           document.getElementById('r1').value = 1; document.getElementById('r2').value = 1; document.getElementById('r3').value = 2;
           btn.style.display = 'block'; btn.innerText = "OK"; return;
        }
        typeNumber(1, 1, 2, () => {
             btn.style.display = 'block'; btn.innerText = "OK";
        });
      }, 500);
      break;

    case 12:
      txt.innerHTML = `真ん中の<b>「予言 β」</b>をタップしろ。<br>
      この石碑は「合計」に関するルールを持っているようだ。`;
      const s1 = document.getElementById('stone-1');
      if(s1) s1.classList.add('tut-highlight', 'tut-blink');
      btn.style.display = 'none';
      break;

    case 13:
      const logFalse = `
        <div class="log-entry log-false" style="margin-top:10px; text-align:left;">
          <div style="width:100%;">
            <div style="display:flex; justify-content:space-between; align-items:center;">
              <span style="font-weight:bold;">R2 予言β</span> <strong>FALSE</strong>
            </div>
            <div style="font-size:0.85rem; margin:4px 0; color:#ddd; padding-left:8px; border-left:2px solid rgba(255,255,255,0.2);">
              ${colorize("合計と10の関係 (<, ≧)")}
            </div>
            <div style="text-align:right;"><span class="log-nums">1-1-2</span></div>
          </div>
        </div>`;
      txt.innerHTML = `判定が出た！<br>${logFalse}<br><b>FALSE</b>（偽り）だ。<br>合計4ではダメらしい。「合計はもっと大きい（10以上）」ということだ！`;
      document.getElementById('log-container').classList.add('tut-highlight');
      break;

    case 14:
      txt.innerHTML = `FALSEが出たことで、正解を絞り込めた。<br>
      しかしまだ情報が足りない。<br>
      続いて<b>「予言 γ」</b>も調べておこう。`;
      break;

    case 15:
      txt.innerHTML = `入力数字は<b>「1 - 1 - 2」</b>のままでいい。<br>
      <b>「予言 γ」</b>をタップして反応を見るんだ。`;
      const s2 = document.getElementById('stone-2');
      if(s2) s2.classList.add('tut-highlight', 'tut-blink');
      btn.style.display = 'none'; 
      break;

    case 16:
      const logGamma = `
        <div class="log-entry log-false" style="margin-top:10px; text-align:left;">
          <div style="width:100%;">
            <div style="display:flex; justify-content:space-between; align-items:center;">
              <span style="font-weight:bold;">R2 予言γ</span> <strong>FALSE</strong>
            </div>
            <div style="font-size:0.85rem; margin:4px 0; color:#ddd; padding-left:8px; border-left:2px solid rgba(255,255,255,0.2);">
              ${colorize("風と5の関係 (<, = )")}
            </div>
            <div style="text-align:right;"><span class="log-nums">1-1-2</span></div>
          </div>
        </div>`;
      txt.innerHTML = `結果は…<br>${logGamma}<br>
      <b>FALSE</b>だ！<br>
      入力した${cWind}(2)ではダメだと言っている。<br>
      つまり、${cWind}<5ではなく、${cWind}=<b>「5」</b>で確定する！`;
      document.getElementById('log-container').classList.add('tut-highlight');
      break;

    // ★追加: 石碑δのフロー
    case 17:
      txt.innerHTML = `まだ終わりではない。最後の石碑がある。<br>
      <b>「予言 δ」</b>をタップして、偶数に関するルールを確認しよう。`;
      break;

    // --- nextTutorialStep関数内 ---

    case 18:
      // 文言変更：偶数個数ではなく、炎の性質について
      txt.innerHTML = `<b>「予言 δ」</b>をタップせよ。<br>
      入力は「1 - 1 - 2」（炎は1）のままだ。<br>
      もし炎が偶数ならTRUE、奇数ならFALSEになるはずだ。`;
      const s3 = document.getElementById('stone-3');
      if(s3) s3.classList.add('tut-highlight', 'tut-blink');
      btn.style.display = 'none';
      break;

    case 19:
      const logDelta = `
        <div class="log-entry log-false" style="margin-top:10px; text-align:left;">
          <div style="width:100%;">
            <div style="display:flex; justify-content:space-between; align-items:center;">
              <span style="font-weight:bold;">R2 予言δ</span> <strong>FALSE</strong>
            </div>
            <div style="font-size:0.85rem; margin:4px 0; color:#ddd; padding-left:8px; border-left:2px solid rgba(255,255,255,0.2);">
              ${colorize("炎の偶奇 (偶数, 奇数)")}
            </div>
            <div style="text-align:right;"><span class="log-nums">1-1-2</span></div>
          </div>
        </div>`;
      
      // 解説ロジックの修正
      txt.innerHTML = `結果は…<br>${logDelta}<br>
      <b>FALSE</b>だ！<br>
      入力した${cFire}「1」(奇数)では条件を満たさない。<br>
      つまり、正解の${cFire}は<b>「偶数 (2か4)」</b>でなければならない！`;
      document.getElementById('log-container').classList.add('tut-highlight');
      break;

    case 20:
      txt.innerHTML = `これですべての条件が揃った。<br>
      <ul style="font-size:0.85rem; padding-left:20px; color:#ddd; text-align:left;">
        <li>予言α: ${cFire} = ${cWater}</li>
        <li>予言β: 合計 ≧ 10</li>
        <li>予言γ: ${cWind} = 5</li>
        <li>予言δ: ${cFire} = 偶数</li>
      </ul>
      ${cFire}が2だと「2+2+5=9」で合計不足。<br>
      ならば、残る可能性はただ一つ！`;
      break;

    case 21:
      txt.innerHTML = `導き出した答え、<b>「4 - 4 - 5」</b>を入力せよ！<br>
      (合計13、風は5、炎は偶数、炎=水。完璧だ)<br>
      ※今回は特別に数字を書き換えてあげよう。`;
      const runeBox3 = document.querySelector('.rune-container');
      if(runeBox3) runeBox3.classList.add('tut-highlight', 'tut-blink');
      btn.style.display = 'none';
      setTimeout(() => {
        if (typeof typeNumber !== 'function') {
           document.getElementById('r1').value = 4; document.getElementById('r2').value = 4; document.getElementById('r3').value = 5;
           btn.style.display = 'block'; btn.innerText = "OK"; return;
        }
        typeNumber(4, 4, 5, () => {
             btn.style.display = 'block'; btn.innerText = "OK";
        });
      }, 500);
      break;

    case 22:
      txt.innerHTML = `これが正解なら、すべての石碑が <b>TRUE</b> になるはずだ。<br>
      最後に<b>「封印解除」</b>ボタンを押して、答え合わせをしよう！`;
      const solveBtn = document.querySelector('.solve-circle').closest('.action-btn-item');
      if(solveBtn) solveBtn.classList.add('tut-highlight', 'tut-blink');
      btn.style.display = 'none'; 
      break;
  }
}


// ▼▼▼ この部分を追加してください ▼▼▼

// ガイドを閉じる
function closeHelp() {
  document.getElementById('help-modal').style.display = 'none';
}

function closeHistory() {
  document.getElementById('history-modal').style.display = 'none';
  // 閉じたときにチュートリアルボタンを復活させる
  const tutBtn = document.getElementById('top-tut-btn');
  if(tutBtn) tutBtn.style.display = 'flex';
}

// --- ID入力モーダル制御 ---
function showInputId() {
  // iPhone対策: 隠す
  const tutBtn = document.getElementById('top-tut-btn');
  if(tutBtn) tutBtn.style.display = 'none';
  
  document.getElementById('id-modal').style.display = 'flex';
  
  // 解放済みならボタンを出す
  const isUnlocked = localStorage.getItem('omega_awakened_unlocked') === 'true';
  const btn = document.getElementById('btn-id-awakened');
  
  if(btn) {
    // 解放済みなら表示(flex)、未解放なら非表示(none)
    btn.style.display = isUnlocked ? 'flex' : 'none';
  }
}

function closeIdModal() {
  document.getElementById('id-modal').style.display = 'none';
  // 復活させる
  const tutBtn = document.getElementById('top-tut-btn');
  if(tutBtn) tutBtn.style.display = 'flex';
}

// 封印解除の演出用
// 1. 確認ポップアップを閉じる
function closeConfirm() {
  document.getElementById('confirm-modal').style.display = 'none';
  
  // ▼▼▼ 「再考する」の場合のみリストを復活させる ▼▼▼
  if (state.isOmega) {
    const omegaArea = document.getElementById('omega-rule-area');
    if (omegaArea) {
      omegaArea.style.display = 'block';
      // renderPropheciesでfallingクラスを消しているので、
      // ここでblockにしても再アニメーションはしません。
    }
  }
}


// 2. 演出を実行してから結果画面へ (Ω対応版)
// 2. 演出を実行してから結果画面へ (修正版)
function executeUnlock() {
  // ▼▼▼ 修正: closeConfirm() を呼ばずに、手動でモーダルだけ閉じる ▼▼▼
  // closeConfirmを呼ぶとOmegaリストが表示されてしまうため、それを防ぎます。
  document.getElementById('confirm-modal').style.display = 'none';
  // ▲▲▲▲▲▲

  const animModal = document.getElementById('gate-anim-modal');
  const gateObj = document.getElementById('gate-circle');
  const gateInner = document.querySelector('.gate-inner'); 
  
  animModal.style.display = 'flex';
  animModal.classList.add('gate-anim-running');
  
  // 十字線の色切り替え
  const lightningSvg = document.querySelector('.lightning-svg');
  if (state.isOmega) {
    lightningSvg.classList.add('omega-mode'); 
  } else {
    lightningSvg.classList.remove('omega-mode'); 
  }

  // リセット
  gateObj.classList.remove('gate-active');
  gateObj.classList.remove('gate-active-omega'); 
  gateObj.classList.remove('gate-stone-omega');  
  gateInner.classList.remove('gate-inner-omega');

  void gateObj.offsetWidth; // リフロー

  // アニメーション分岐
  let animTime = 2300; 

  if (state.isOmega) {
    // Ωモード
    gateObj.classList.add('gate-stone-omega');
    gateInner.classList.add('gate-inner-omega');
    gateObj.classList.add('gate-active-omega'); 
    animTime = 3800; 
  } else {
    // 通常モード
    gateObj.classList.add('gate-active');
  }

  // アニメーション終了後
  setTimeout(() => {
    animModal.style.display = 'none';
    animModal.classList.remove('gate-anim-running');
    gateObj.classList.remove('gate-active');
    gateObj.classList.remove('gate-active-omega'); 
    
    // 判定
    const i = +document.getElementById('r1').value;
    const a = +document.getElementById('r2').value;
    const v = +document.getElementById('r3').value;
    const isCorrect = (i === state.ans.i && a === state.ans.a && v === state.ans.v);
    
    finishGame(isCorrect);
    
  }, animTime); 
}

// --- 予言リストの開閉 ---
function showProphecyList() {
  document.getElementById('prophecy-list-modal').style.display = 'flex';
}
function closeProphecyList() {
  document.getElementById('prophecy-list-modal').style.display = 'none';
}

// ゲームをリロードせずに初期化してタイトルに戻す関数
function softResetGame() {
  // 1. モーダルや演出を消す
  document.querySelectorAll('.modal-overlay').forEach(m => m.style.display = 'none');
  const frame = document.querySelector('.divine-frame');
  if(frame) frame.remove();
  
  document.body.style.backgroundImage = ""; 
  
  const manaBar = document.querySelector('.mana-bar');
  if(manaBar) {
    manaBar.style.color = "";       // 赤色を解除（CSSのデフォルトに戻す）
    manaBar.style.textShadow = "";  // 発光エフェクトを解除
    manaBar.classList.remove('glitch-active'); // 念のためグリッチクラスも削除
  }

  // 2. 画面切り替え（ゲーム画面を隠してタイトルを出す）
  document.getElementById('game-screen').style.display = 'none';
  document.getElementById('title-screen').style.display = 'flex'; 
  
  // ▼▼▼ これを追加！(タイトルに戻ったら表示) ▼▼▼
  const tutBtn = document.getElementById('top-tut-btn');
  if(tutBtn) tutBtn.style.display = 'flex';
  // ▲▲▲▲▲▲
  
  // ▼▼▼ ★追加修正: ここで「警告メッセージ」を確実に消す！ ▼▼▼
  const lockMsg = document.getElementById('rune-lock-msg');
  if(lockMsg) lockMsg.style.display = 'none';
  // ▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲

  // 3. データのリセット
  document.getElementById('r1').value = '';
  document.getElementById('r2').value = '';
  document.getElementById('r3').value = '';
  document.getElementById('r1').disabled = false;
  document.getElementById('r2').disabled = false;
  document.getElementById('r3').disabled = false;
  
  document.getElementById('log-container').innerHTML = '';
  document.getElementById('prophecy-container').innerHTML = '';
  // ▼▼▼ 修正: 中身だけでなく、枠ごと消し去る！ ▼▼▼
  const omegaList = document.getElementById('omega-list');
  if(omegaList) omegaList.innerHTML = ''; 
  
  // ★これを追加してください
  const omegaArea = document.getElementById('omega-rule-area');
  if(omegaArea) omegaArea.style.display = 'none';
  
  initMatrix(); 
  const memoPad = document.getElementById('memo-pad');
  if(memoPad) memoPad.classList.add('closed');

  // カオス警告のリセット
  const chaosWarn = document.getElementById('chaos-warning');
  if(chaosWarn) {
    chaosWarn.style.display = 'none';
    chaosWarn.classList.remove('visible');
  }

  // ▼▼▼ ★追加: Nightmare警告のリセット ▼▼▼
  const nmWarn = document.getElementById('nightmare-warning');
  if(nmWarn) {
    nmWarn.style.display = 'none';
    nmWarn.classList.remove('visible');
  }
  checkAwakenedUnlock();
}


// MENUボタンを押したとき
function openMenuModal() {
  document.getElementById('menu-modal').style.display = 'flex';
  
  // ▼▼▼ 追加: メニューを開いている間は、Omegaリストを完全に消す ▼▼▼
  const omegaArea = document.getElementById('omega-rule-area');
  if(omegaArea) omegaArea.style.display = 'none';
  // ▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲
}

// キャンセルを押したとき
function closeMenuModal() {
  document.getElementById('menu-modal').style.display = 'none';
  
  // ▼▼▼ 追加: メニューを閉じた時、Omegaモード中ならリストを復活させる ▼▼▼
  // (タイトルに戻る時は softResetGame 側で消してくれるので大丈夫です)
  if(state.isOmega) {
    const omegaArea = document.getElementById('omega-rule-area');
    if(omegaArea) omegaArea.style.display = 'block';
  }
  // ▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲
}


// 終了するを押したとき（さっき作ったリセット関数を再利用！）
function executeBackToTitle() {
  closeMenuModal();
  softResetGame(); // ステップ2で作った関数を呼び出すだけでOK
}

// チュートリアルを中断してタイトルに戻る
function quitTutorial() {
  isTutorialMode = false;
  // 演出用クラスの除去
  document.querySelectorAll('.tut-highlight').forEach(e => e.classList.remove('tut-highlight'));
  document.querySelectorAll('.tut-blink').forEach(e => e.classList.remove('tut-blink'));
  
  // BOXを隠す
  const tutBox = document.getElementById('tut-box');
  if(tutBox) {
    tutBox.style.display = 'none';
    tutBox.classList.remove('tut-embedded-mode');
    document.body.appendChild(tutBox); // DOM位置リセット
  }
  document.getElementById('tut-overlay').style.display = 'none';
  
  // UIの復元
  const matrix = document.getElementById('logic-matrix');
  if(matrix) matrix.style.display = '';
  const memoBtn = document.querySelector('.memo-toggle-btn');
  if(memoBtn) memoBtn.style.display = '';
  const memoPad = document.getElementById('memo-pad');
  if(memoPad) memoPad.style.display = '';
  const runeContainer = document.querySelector('.rune-container');
  if(runeContainer) {
      const matrixLabel = runeContainer.nextElementSibling;
      if(matrixLabel) matrixLabel.style.display = '';
  }
  // ゲームリセットしてタイトルへ
  softResetGame();
}

window.onload = () => { checkAwakenedUnlock(); };

// ★新規: 解放アニメーションの実行
function playUnlockAnimation() {
  const overlay = document.getElementById('awakened-unlock-overlay');
  if(!overlay) return;
  
  // リザルト画面などを一時的に隠す（没入感を高めるため）
  const resultModal = document.getElementById('result-modal');
  if(resultModal) resultModal.style.opacity = '0';

  // 効果音の代わり（振動APIがあれば揺らす）
  if (navigator.vibrate) navigator.vibrate([100, 50, 100]);

  overlay.style.display = 'flex';

  // 5秒後に消して、リザルト画面を戻す
  setTimeout(() => {
    overlay.style.transition = 'opacity 1s';
    overlay.style.opacity = '0';
    
    setTimeout(() => {
      overlay.style.display = 'none';
      overlay.style.opacity = '1'; // 次回用にリセット
      
      // リザルト画面をふわっと戻す
      if(resultModal) {
          resultModal.style.transition = 'opacity 1s';
          resultModal.style.opacity = '1';
      }
      
      // ここでアラートを出してもいい
      alert("【 Awakened Omega Mode 】 unlocked.\nタイトル画面に新たな扉が開かれました。");
      
    }, 1000);
  }, 5000); // 演出時間
 }
  
  // 真OMEGAモード開始の確認関数
function confirmAwakened() {
  // そのままスタートさせるか、確認を挟むか選べます。
  // ここでは雰囲気を出すために確認ダイアログを出します。
  if(confirm("【警告】\nこれより先は、論理の深淵「Awakened Omega」です。\n非常に難易度が高いですが、挑戦しますか？")) {
    startGame('awakened');
  }
}

// ▼▼▼ 砂時計を「常に未来へ」回転させる魔法 ▼▼▼
let nextIconAngle = 0;

function spinNextIcon() {
  // 角度を360度足す（戻らずに先に進む）
  nextIconAngle += 360;
  
  // 画像を探して回す
  const icon = document.querySelector('.next-circle .action-img');
  if(icon) {
    icon.style.transform = `rotate(${nextIconAngle}deg)`;
  }
}
// ▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲


</script>


<div id="confirm-modal" class="modal-overlay">
  <div style="background:#111; padding:25px; border:1px solid #d4af37; border-radius:10px; width:85%; max-width:350px; text-align:center; box-shadow:0 0 30px rgba(212, 175, 55, 0.2);">
    <h3 style="color:#ccc; margin-top:0; font-size:1rem;">封印を解除しますか？</h3>
    
    <div style="font-family:'Cinzel', serif; font-size:2.5rem; color:#d4af37; margin:15px 0; letter-spacing:5px; font-weight:bold; text-shadow:0 0 10px rgba(212, 175, 55, 0.5);">
      <span id="confirm-nums">???</span>
    </div>
    
    <div style="font-size:0.8rem; color:#888; margin-bottom:20px;">
      一度解除すると、やり直しはできません。<br>
      このコードで確定しますか？
    </div>

    <div style="display:flex; gap:10px;">
      <button class="btn btn-std" style="border-color:#555; color:#aaa;" onclick="closeConfirm()">再考する</button>
      <button class="btn btn-std" style="background:#d4af37; color:#000; border-color:#fff; font-weight:bold;" onclick="executeUnlock()">解除！！</button>
    </div>
  </div>
</div>

<div id="gate-anim-modal" class="modal-overlay" style="background:#000; z-index:11000;">
  
  <svg class="lightning-svg" width="100%" height="100%" viewBox="0 0 100 100" preserveAspectRatio="none">
  <defs>
    <filter id="glow-gold" x="-50%" y="-50%" width="200%" height="200%">
      <feGaussianBlur stdDeviation="0.5" result="blur1" />
      <feMerge>
        <feMergeNode in="blur1" />
        <feMergeNode in="SourceGraphic" />
      </feMerge>
    </filter>
  </defs>
  
  <g class="cross-line-group">
    <path class="lightning-path main" d="M50,50 L50,0 M50,50 L50,100 M50,50 L0,50 M50,50 L100,50" />
    <path class="lightning-path sub" d="M50,50 L20,20 M50,50 L80,20 M50,50 L20,80 M50,50 L80,80" />
    <path class="lightning-path sub" d="M50,50 L40,10 L50,50 L90,40 L50,50 L60,90 L50,50 L10,60" />
  </g>
</svg>

  <div id="gate-circle" class="gate-stone">
    <div class="gate-inner">Ω</div>
  </div>
</div>

<div id="menu-modal" class="modal-overlay">
  <div style="background:#111; padding:25px; border:1px solid #555; border-radius:10px; width:85%; max-width:300px; text-align:center; box-shadow:0 0 20px rgba(0,0,0,0.8);">
    <h3 style="color:#fff; margin-top:0; border-bottom:1px solid #333; padding-bottom:10px;">MENU</h3>
    <div style="color:#ccc; margin:20px 0; font-size:0.95rem;">
      現在のゲームを終了しますか？<br>
      <span style="font-size:0.8rem; color:#888;">(進行状況は失われます)</span>
    </div>
    <div style="display:flex; gap:10px; justify-content:center;">
      <button class="btn btn-std" style="flex:1; padding:10px; border-color:#777; color:#ccc;" onclick="closeMenuModal()">キャンセル</button>
      <button class="btn btn-std" style="flex:1; padding:10px; border-color:#e74c3c; color:#e74c3c; font-weight:bold;" onclick="executeBackToTitle()">終了する</button>
    </div>
  </div>
</div>

<div id="awakened-unlock-overlay" style="display:none;">
  <div class="unlock-content">
    <div class="unlock-icon">Ω+</div>
    <div class="unlock-text-main">禁忌の封印が解かれた</div>
    <div class="unlock-text-sub">Awakened Omega Unlocked</div>
  </div>
</div>

<div id="review-modal" class="modal-overlay">
  <div class="review-content" style="background:#111; padding:20px; border:1px solid #444; border-radius:10px; width:90%; max-width:500px; max-height:85vh; overflow-y:auto; position:relative; display:flex; flex-direction:column; gap:15px;">
    
    <div class="close-help" onclick="closeReview()">×</div>
    <h3 style="color:#fff; margin:0; border-bottom:1px solid #333; padding-bottom:10px;">探査記録詳細</h3>

    <div id="review-header" style="display:flex; justify-content:space-between; align-items:center; font-size:0.9rem; color:#aaa;"></div>

    <div id="review-answer-box" style="background:#000; padding:10px; border-radius:6px; border:1px solid #333; text-align:center;"></div>

            <div style="text-align:left;">
      <div style="font-size:0.8rem; color:#d4af37; margin-bottom:5px;">
        <img src="icon_memo.png" class="memo-icon-img" alt="Memo"> 当時のメモ
      </div>
      <textarea id="review-memo" readonly style="width:100%; height:100px; background:#1a1a1a; border:1px solid #333; color:#ccc; padding:8px; border-radius:4px; font-family:'Shippori Mincho', serif; box-sizing:border-box; resize:none;"></textarea>
    </div>


    <div style="text-align:left; flex:1; min-height:0; display:flex; flex-direction:column;">
      <div style="font-size:0.8rem; color:#d4af37; margin-bottom:5px;">📜 解析ログ</div>
      <div id="review-log" style="background:#000; border:1px solid #333; padding:10px; border-radius:4px; overflow-y:auto; flex:1; max-height:200px; font-size:0.8rem;"></div>
    </div>

    <button class="btn btn-std" onclick="closeReview()" style="width:100%; margin:0;">閉じる</button>
  </div>
</div>

<div id="prophecy-list-modal" class="modal-overlay">
  <div id="prophecy-list-content">
    <div class="close-help" onclick="closeProphecyList()">×</div>
    <h3 style="color:#d4af37; margin-top:0; border-bottom:1px solid #333; padding-bottom:10px; text-align:center;">予言の解読書</h3>
    
    <div class="p-cat-title" style="color:#ff9999;">■ 基本・比較</div>
    
    <div class="p-item">
      <strong>[属性]と[数字]の関係 ( <, =, > )</strong><br>
      例: 「炎と3の関係」など。<br>
      そのルーンが指定された数字より大きいか小さいか 同一か。<br>
      <span class="p-ex">判定: 炎が4でTRUEなら「炎 > 3」</span>
    </div>

    <div class="p-item">
      <strong>[属性]と[属性]の比較 ( <, =, > )</strong><br>
      例: 「炎と水の比較」など。<br>
      2つのルーンの大きさを比べる。<br>
      <span class="p-ex">判定: 炎4・水2でTRUEなら「炎 > 水」</span>
    </div>

    <div class="p-item">
      <strong>順序の法則 (昇順, 降順, 順不同)</strong><br>
      3つの数字の並び方。<br>
      <span class="p-ex">
        昇順: 1-2-5 (増えていく)<br>
        降順: 5-3-2 (減っていく)<br>
        順不同: 1-5-5 (バラバラ)
      </span>
    </div>

    <div class="p-item">
      <strong>最大値の所在 (≧) / 最小値の所在 (≦)</strong><br>
      誰が一番大きい(または小さい)か。<br>
      <span class="p-ex">判定: 5-2-2でTRUEなら「炎が最大」</span>
    </div>


    <div class="p-cat-title" style="color:#99ccff;">■ 数学・合計</div>

    <div class="p-item">
      <strong>[属性]の偶奇 (偶数, 奇数)</strong><br>
      その数字が2で割り切れるかどうか。<br>
      <span class="p-ex">判定: 炎が4でTRUEなら「炎=偶数」</span>
    </div>

    <div class="p-item">
      <strong>合計の偶奇 (偶数, 奇数)</strong><br>
      3つの合計値が偶数か奇数か。<br>
      <span class="p-ex">判定: 1+2+4=7 でTRUEなら「合計は奇数」</span>
    </div>

    <div class="p-item">
      <strong>合計と[数字]の関係 ( <, ≧ )</strong><br>
      例: 「合計と10の関係」など。<br>
      3つの合計が基準(6や10)より大きいか小さいか。<br>
      <span class="p-ex">判定: 合計11でTRUEなら「合計 ≧ 10」</span>
    </div>

    <div class="p-item">
      <strong>合計が特定の倍数(2, 3, 5)</strong><br>
      合計値がその数で割り切れるか。<br>
      <span class="p-ex">判定: 合計10でTRUEなら「5の倍数」「2の倍数」</span>
    </div>
    
    <div class="p-item">
      <strong>[属性]+[属性]と5の関係 ( <, =, > )</strong><br>
      例: 「炎+水と5の関係」など。<br>
      指定された2つの和が5より大きいか小さいか。<br>
      <span class="p-ex">判定: 3+3=6でTRUEなら「炎+水 > 5」</span>
    </div>

    <div class="p-item">
      <strong>合計値が素数かどうか</strong><br>
      合計が 3, 5, 7, 11, 13 のいずれかである。<br>
      <span class="p-ex">判定: 合計5でTRUEなら「合計は素数」</span>
    </div>

    <div class="p-item">
      <strong>素数の有無 (あり, なし)</strong><br>
      数字の中に素数(2, 3, 5)が1つでも含まれるか。<br>
      <span class="p-ex">判定: 1-1-4 (なし) / 1-1-2 (あり)</span>
    </div>


    <div class="p-cat-title" style="color:#99ffcc;">■ 構造・パターン</div>

    <div class="p-item">
      <strong>[数字]の数 (0, 1, 2, 3)</strong><br>
      例: 「偶数の数」「1の数」など。<br>
      条件に合う数字がいくつあるか。<br>
      <span class="p-ex">判定: 2-3-5 でTRUEなら「偶数が1個」</span>
    </div>

    <div class="p-item">
      <strong>隣接する連番の数(0 , 1 , 2)</strong><br>
      隣り合う数字の差が「1」である箇所の数。<br>
      <span class="p-ex">
        4-5-1 (4と5) → 1箇所<br>
        1-2-3 (1と2, 2と3) → 2箇所<br>
        1-3-5 (繋がりなし) → 0箇所
      </span>
    </div>

    <div class="p-item">
      <strong>2つの同じ数字 (なし, 1組)</strong><br>
      ペアが含まれているか (ワンペア)。<br>
      <span class="p-ex">判定: 2-2-5 (1組) / 1-2-3 (なし)<br>
 ※1組の場合2-2-2を入れてもTRUEを返します。</span>
    </div>

    <div class="p-item">
      <strong>最大と最小の差(0 ,1 ,2 ,3 ,4)</strong><br>
      一番大きい数 - 一番小さい数。<br>
      <span class="p-ex">判定: 2-5-5でTRUEなら 5-2=3 なので「差が3」</span>
    </div>

    <button class="btn btn-std" onclick="closeProphecyList()" style="width:100%; margin-top:20px;">閉じる</button>
  </div>
</div>

<div id="nightmare-slash" class="slash-effect">
  <div class="slash-line" style="top: 15%; left: -10%; width: 120%; height: 4px;"></div>
  <div class="slash-line" style="top: 25%; left: -10%; width: 120%; height: 2px;"></div>
</div>

<div id="judge-popup" style="
  position: fixed; top: 0; left: 0; width: 100%; height: 100%;
  pointer-events: none; z-index: 9999;
  display: flex; justify-content: center; align-items: center;
">
  <div id="judge-text" class="en-font" style="
     font-size: 5rem; font-weight: 900; opacity: 0;
     text-shadow: 0 0 30px rgba(0,0,0,0.8);
     letter-spacing: 5px;
  "></div>
</div>


</body>
</html>
